#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################



## we need a canonical way of working out what platform we're running
## on, R and S differ and even versions of R have different os settings...
emu.platform <- function(what) {
  if( is.R() ) {
    if(version$platform == "Windows" ||
       version$os == "Win32" ||
       version$os == "mingw32") {
      return(what == "Windows")
    } else if (
	version$os == "MacOS" ||
	substr(version$os,0,6) == "darwin" ) {
      return(what == "MacOS")
    } else {
      return(what == "Unix")
    }
  } else {
    if( version$platform == "WIN386" ) {
      return(what == "Windows")
    } else {
      return(what == "Unix")
    }
  }
}


## Modify the value of emu.directory to match your Emu installation, for
## example if you have Emu installed on your Windows machine under
## C:\My Programs\Emu then change the value of 'emu.directory' below to
## "C:\\My Programs\\Emu" (note that you must always double the slashes
## for Splus).

if (emu.platform("Windows")) {

  emu.directory <- "C:\\Program Files\\Emu"

} else if ( emu.platform("MacOS") ) {
  ## macos can't exec so it doesn't really matter
  emu.directory <- ""
} else {

  ## change this value for unix
  emu.directory <- "/usr/local"

}

### ------------------------------------------------------------------------
### ----------There are no more user configurable values in this file ------
### ------------------------------------------------------------------------


## this will get changed by the Makefile
emu.version<-"2.1"

"emu.init" <- function() {

  packpath = .path.package(package = "emu", quiet = FALSE)
  sepa = .Platform$file.sep
  nfile = "emudirectory"
  filepath = paste(packpath,sepa,nfile,sep = "")
  
  if (file.exists(filepath)) {
    emu.directory <<- readLines(con = filepath)
  } 
	
  if (emu.platform("MacOS")) {
    dirsep <- ":"
    gettrack <- ""
  } else if (emu.platform("Windows")) {
    dirsep <- "\\"
    gettrack <- "gettrack.exe"
  } else if (emu.platform("Unix")) {
    dirsep <- "/"
    gettrack <- "gettrack"
  } else {
    stop("Panic! I can't work out what platform I'm running on!\
Please report this as  a bug at http://sf.net/projects/emu including\
details of the operating system you are running on and the value of\
the variable 'version'.")
  }

  if (emu.platform("MacOS")) {
    bindir <- ""
  } else {
    bindir <- paste(emu.directory, "bin", sep=dirsep)                   

    ## test emu.directory to find one of the executables, query if
    ## it isn't found
    crashout <- FALSE
    modified <- FALSE

    while( !crashout  &&
          !file.exists( paste( bindir, gettrack, sep=dirsep ) ) ) {

      cat( "Configuration error: emu.directory (", emu.directory, ") doesn't\n" )
      cat( "correspond to an Emu installation.\n" )
      cat( "Please enter the directory in which Emu is installed\n" )
      cat( "on your system, eg. C:\\Program Files\\Emu on Windows \n" )
      cat( "or /usr/local on Unix.\n\n" )
      cat( "Enter nothing and press return to exit this configuration loop.\n\n")

      ## we assign to the global namespace to make sure this is retained
      emu.directory <<-  readline( "Emu Directory: " )
      modified <- TRUE
      if( emu.directory == "" ) {
        crashout <- TRUE
      } else {
        bindir <- paste(emu.directory, "bin", sep=dirsep)
      }
    }
    
    if( crashout ) { return( FALSE ) }
    if( modified && is.R() ) {

      write(emu.directory, file = filepath)
      cat("\nThis information was written to the file\n",
      filepath,".\n") 
           
    }

  }

  if( is.R() ) {
    assign( "emu", 
         list( 
              version=emu.version,
              deprecated.warnings=1,
              bindir=bindir,
              dirsep=dirsep,
	      gettrack=gettrack
              ),
           env = .GlobalEnv )
  } else {
    assign( "emu",
           list( 
                version=emu.version,
                deprecated.warnings=1,
                bindir=bindir,
                dirsep=dirsep,
                gettrack=gettrack
                ),
           frame=0)
  }

  
  if( is.R() ) {
    ## eda is needed for smooth, used in dsmooth
    library("eda")
    ## mva is needed by euclidean
    library("mva")
    
  }

  invisible()
}


"emu.options" <- function( option ) {
    emu[[option]]
}

"bark" <-
function(f, inv=F)
{
# Convert Bark to Hz and vice-versa
# Formulae in 
# H. Traunmüller (1990) "Analytical expressions for the 
# tonotopic sensory scale" J. Acoust. Soc. Am. 88: 97-100. 
# f is a frequency in Hz unless inv=T,
# in which case f is a frequency in Bark
# inv: if T, performs Bark to Hz conversion
if(!inv)
result = ((26.81 * f) / (1960+f)) - 0.53
else
result = (1960 * (f + 0.53)) / (26.28 - f)
result
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"mahal" <- function(data, train)
{
  if (emu.options("deprecated.warnings"))
    cat("mahal is deprecated, use classify with metric=\"mahal\"\n")
  classify( data, train, metric="mahal" )
}

"bayes.lab" <- function(data, train)
{
  if (emu.options("deprecated.warnings"))
    cat("bayes.lab is deprecated, use classify with metric=\"bayes\"\n")
  classify( data, train, metric="bayes" )
}

"bayes.dist"<-
  function(data, train, labels=NULL)
{
  if (emu.options("deprecated.warnings"))
    cat("bayes.dist is deprecated, use distance with metric=\"bayes\"\n")
  distance( data, train, labels, metric="bayes")
}

"mahal.dist" <-
  function( data, train, labels=NULL )
{
  if (emu.options("deprecated.warnings"))
    cat("mahal.dist is deprecated, use distance with metric=\"mahal\"\n")
  distance( data, train, labels, metric="mahal")
}


## generalise bayes.dist and mahal.dist
"distance" <-
  function( data, train, labels=NULL, metric="bayes" )
{
  ## data is a set of data points
  ## train is the result of the train fn and contains
  ##  $mean - the centroids
  ##  $cov  - the covariance matrices
  ##  $invcov - the inverse covariance matrix
  ##  $label - the corresponding labels
  ## labels - an optional set of labels corresponding to data
  ## metric - one of "bayes" or "mahal" for bayesian or mahalanobis distance
  
  if(!is.matrix(data)) data <- cbind(data)

  ncols <- length(train$label)
  ndims <- ncol(data)
  probs <- matrix(0, nrow = nrow(data), ncol = ncols)

  for(lab in 1:ncols) {
    tmp <- (lab - 1) * ndims + 1
    tmp1 <- tmp + ndims - 1
    cov <- train$cov[tmp:tmp1,  ]
    invcov <- train$invcov[tmp:tmp1,  ]
    if ( metric == "bayes" ) {
      probs[, lab] <- bayesian.metric(data, train$means[lab,  ], cov, invcov)
    } else if ( metric == "euclidean" ) {
      probs[, lab] <- euclidean.metric(data, train$means[lab,  ])
    } else if ( metric == "mahal" ) {
      probs[, lab] <- mahalanobis.metric(data, train$means[lab,  ], invcov)
    }            
  }
  dimnames(probs) <- list(labels, train$label)
  probs
}

"euclidean.metric" <- function( data, mean )
{
  return 
}


"bayesian.metric" <- 
  function( data, mean, cov, invcov )
{
  # calcuate the gaussian classification metric for multivariate data
  # given mean vector and covariance matrix
  det <- -log(as.numeric(prod(eigen(cov)$value)))
  x.u <- t(data) - mean
  pow <- t(x.u) %*% invcov
  ## this is really pow %*% x.u if x.u were just one point but it isn't
  ## it's many points so we can't just matrix multiply
  return( det - apply(pow * t(x.u), 1, sum) )
}

"mahalanobis.metric" <-
  function(data, mean, invcov)
{
  x.u <- t(data) - mean
  pow <- t(x.u) %*% invcov
  ## this is really pow %*% x.u if x.u were just one point but it isn't
  ## it's many points so we can't just matrix multiply
  return( apply(pow * t(x.u), 1, sum) )
}


"classify" <- function(data, train, metric="bayes")
{
  probs <- distance(data, train, metric=metric )

  ## what's best depends on the metric, bayes is a prob. so max is best
  ## mahal is a distance so min is best
  if( metric=="bayes" ) {
    best <- apply(probs, 1, max)
  } else if ( metric=="mahal" ) {
    best <- apply(probs, 1, min)
  }
  
  result <- rep("", length(best))
  for(lab in 1:length(train$label)) {
    tmp <- probs[, lab] == best
    result[tmp] <- train$label[lab]
  }
  result
}


bayesplot <- function(data, train, N = 10, ellipse = F, 
		      labs = NULL, xlab="", ylab="", colour=T, ...)
{
  ## data is the original data, used for scaling
  ## train is the stuff you get from train()
  rx <- range(data[, 1])
  ry <- range(data[, 2])  
  ## make a set of points covering the plane 0,1
  points <- cbind(sort(rep(1:N/N, N)), rep(1:N/N, N))
  ## Now scale them to the data
  points[, 1] <- points[, 1] * (rx[2] - rx[1]) + rx[1]
  points[, 2] <- points[, 2] * (ry[2] - ry[1]) + ry[1]
  ## now classify each point
  blabs <- classify(points, train, metric="bayes")
  plot(points, type = "n", xlim = rx, ylim = ry, xlab=xlab, ylab=ylab)
  ulabs <- unique(blabs)
  k <- 1
  colours <- mu.colour( ulabs, colour, F )$colour
  for(j in ulabs) {
    temp <- muclass(blabs, j)
    text(points[temp,  ], blabs[temp], col = colours[k])
    k <- k + 1
  }
  if(ellipse && !is.null(labs) ) {
    par(new = T)
    eplot(data, labs, xlim = rx, ylim = ry, colour=colour, ...)
  }
}

"train"<- function(x, lab=rep("x",nrow(x)))
{
  mat <- NULL
  if(is.matrix(x)){
    summeanvals <- NULL
    sumcovvals <- NULL
    sumcovvals.inv <- NULL
    for(j in unique(lab)) {
      temp <- lab == j
      # can only do this if there's more than one row
      if( sum( temp ) == 1 ) {
        ## what to do??
        ## can't do anything sensible so barf and tell them why
        stop( "\n\tData passed to train has only one entry for one of the labels.\n\tA gaussian model can't be generated for this data." )
      }
      values <- x[temp,]
      meanvals <- apply(values, 2, mean)
      covvals <- var(values, values)
      covvals.inv <- solve(covvals)
      summeanvals <- rbind(summeanvals, meanvals)
      sumcovvals <- rbind(sumcovvals, covvals)
      sumcovvals.inv <- rbind(sumcovvals.inv, covvals.inv)
    }
    mat$label <- unique(lab)
    mat$means <- summeanvals
    mat$cov   <- sumcovvals
    mat$invcov <- sumcovvals.inv
  }  else { # the one dimensional case
    mat <- NULL
    mat$means <- NULL
    mat$cov <- NULL
    for(j in unique(lab)) {
      cat("data for ", j, " \n" )
      temp <- lab == j			
      mat$means <- c(mat$means, mean(x[temp]))
      mat$cov <- c(mat$cov, sqrt(var(x[temp])))
    }
    mat$label <- unique(lab)
    mat$invcov <- 1/mat$cov   # in fact this won't be used in the 1d case
  }
  mat
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"bind"<- function(a,...)
{
  UseMethod("bind")
}

  ## default is just to use rbind
"bind.default" <- rbind


"bind.trackdata"<- function(...)
{
  ## function to combine datasets into one single datasets
  ## any number of datasets accepted e.g. dcombine(x, y, z)
  ## where x, y, z are lists of the form $data, $index, $ftime
  mat <- NULL
  for(j in list(...)) {
    if(is.matrix(j$data))
      mat$data <- rbind(mat$data, j$data)
    else mat$data <- c(mat$data, j$data)
    mat$index <- rbind(mat$index, j$index)
    if(!is.null(j$ftime))
      mat$ftime <- rbind(mat$ftime, j$ftime)
  }
  ## readjust the index times
  diffinds <- mat$index[, 2] - mat$index[, 1] + 1
  right <- cumsum(diffinds)
  first.left <- diffinds - 1
  left <- right - first.left
  mat$index <- cbind(left, right)
  if( version$major >= 5 ) {
    oldClass(mat) <- "trackdata"
  } else {
    class(mat) <- "trackdata"
  }
  mat
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"buildtrack" <-
function(mylist, ftime=NULL, trackname="")
{
# convert a list that is usually output from by() into
# a trackdata object

# examples
# p = by(vowlax.fdat[1:3,2], diff)
# m = trackfromlist(p)
# p = by(vowlax.fdat[1:3,], apply, 2, diff)
# o = trackfromlist(p)
# r = by(vowlax.fdat[1:3,2], smooth)
# should break because no ftimes
# trackfromlist(r)
# e = trackfromlist(r, ftime=vowlax.fdat[1:3,]$ftime)
# m = by(vowlax.fdat[1:3,], apply, 2, smooth)
# e = trackfromlist(m, ftime=vowlax.fdat[1:3,]$ftime)

res <- NULL
for(j in 1:length(mylist)){
if(!is.matrix(mylist[[j]]))
mylist[[j]] <- cbind(mylist[[j]])
N <- nrow(mylist[[j]])
if(is.null(ftime))
{
if(is.null(dimnames(mylist[[j]])[[1]]))
stop("can't find any ftime values")
times <- as.numeric(dimnames(mylist[[j]])[[1]])
times <- c(times[1], times[N])
}
else 
times <- ftime[j,]
res$data <- rbind(res$data, cbind(mylist[[j]]))
res$index <- c(res$index, N)
res$ftime <- rbind(res$ftime, times)
}
# build indices
n <- res$index
right <- cumsum(n)
left <- c(1, right+1)
left <- left[-length(left)]
res$index <- cbind(left, right)
as.trackdata(res$data, res$index, res$ftime, trackname)
}

"by.trackdata" <-
function (trackdata, fun, ..., simplify = F) 
{
    n = 1:nrow(trackdata$index)
    indices = rep(n, trackdata$index[, 2] - trackdata$index[, 
        1] + 1)
    result <- o <- by(I(trackdata$data), indices, fun, ...)
    if (simplify) {
        if (is.null(attributes(summary(o))$dim)) 
            result <- c(unlist(o))
        else {
            result <- NULL
            for (j in 1:length(o)) {
                result <- rbind(result, o[[j]])
            }
        }
    }
    result
}

"cbind.trackdata" <-
function (...) 
{
mat <- NULL
k <- 1
    for (j in list(...)) {
if(k==1)
{
inds <- mat$index <- j$index
mat$ftime <- j$ftime
}
else
{ 
if( nrow(j$index) != nrow(inds) )
stop("can't column bind trackdata from different segment lists")
lvec = (j$index[,1]==inds[,1]) & (j$index[,2]==inds[,2])
if(any(!lvec))
stop("can't column bind trackdata from different segment lists")
}
k = k+1
}



 for (j in list(...)) {
            mat$data <- cbind(mat$data, j$data)
        }

    if (version$major >= 5) {
        oldClass(mat) <- "trackdata"
    }
    else {
        class(mat) <- "trackdata"
    }
    mat
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"cepstrum"<- function(vals, points = 20, spectrum = F)
{
  ## vals:  a matrix of spectral values. Output of muspec
  ## points: number of cepstral coefficients; 
  ## roughly 20 for a sam. rate of 20 kHz
  ## spectrum: if T, a cepstrally smoothed spectrum is calculated
  ## that can then be plotted using the fft.plot() function
  ## the cepstral coefficients are stored in mat$coeff
  ## the cepstrally smoothed spectrum in mat$cep
  ## examples: mu.sub36
  ## written by Jonathan Harrington, 1992
  mat <- NULL

  if(!is.matrix(vals)) vals <- rbind(vals)

  z <- vals[, -ncol(vals)]
  x <- rev(t(z))

  ycol <- ncol(z)
  if(is.null(ycol)) ycol <- length(z)

  x <- matrix(x, ncol = ycol, byrow = T)
  x <- apply(x, 2, rev)
  if(!is.matrix(x)) x <- rbind(x)

  newvals <- cbind(vals, x)

  cepvals <- cepstrum.complex(newvals, points = points)

  mat$coeff <- t(cepvals[1:points,  ])

  if(spectrum) {
    results <- cep.db(cepvals)
    colnum <- (ncol(results)/2) + 1
    mat$cep <- results[, 1:colnum]
  }
  mat
}



"cepstrum.complex"<- function(logvals, points = NULL, normlen = T)
{
  ## logvals are in db and would usually be output from the
  ## Fft.db function. If logvals is a matrix, successive rows
  ## correspond to different segments. logvals can
  ## also be a vector corresponding to a single segment
  ## Note: logvals should
  ## be db values of the REFLECTED spectrum, i.e. all
  ## 200 columns for a 200 point fft. 
  ## points: the number of cepstral coefficients to be
  ## calculated. The output is a set of paired real and
  ## imaginary parts, with all values set to zero except
  ## the first 20 and last 19 values if points is set to 20
  ## If normlen is true, the inverse fft is divided by the
  ## square root of the number of points

  if(is.matrix(logvals) == F) logvals <- rbind(logvals)

  n <- ncol(logvals)

  ## apply inverse fft to each row of the data
  invlogvals <- apply(logvals, 1, fft, inverse = T)

  if(normlen) invlogvals <- invlogvals/sqrt(n)

  if(!missing(points)) {
    lowlim <- points + 1
    upplim <- n - points + 2
    invlogvals[lowlim:upplim,  ] <- 0
  }
  invlogvals
}


"cep.db"<- function(cep.mat)
{
# cep.mat: cepstral coefficients that are the output of
# the cepstrum.complex program. the nth columns of cep.mat is
# parallel to any segment list.
# the result returned is the spectrum of the cepstral coefficients
# such that the nth row is parallel to the segment list
	complexvals <- fft.complex(cep.mat)
	-(fft.mod(complexvals))
}




# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################



#############################################################################
# confusion --
#    generate a confusion matrix from two sets of labels
#
# Returns:
#    a square confusion matrix
#
#############################################################################
"confusion"<- function(labx, laby, perc = F)
{
	mat <- NULL
        ## find labels for both axes
        labels <- sort(unique(c(labx,laby)))

	numx <- match(labx, labels)
	numy <- match(laby, labels)

	mat <- matrix(0, length(labels), length(labels))

	for(j in 1:length(labx)) {
	  mat[numx[j], numy[j]] <- mat[numx[j], numy[j]] + 1
	}

	dimnames(mat) <- list(labels, labels)
	if(perc) mat <- percent(mat)
	mat
}

"percent"<- function(data)
{
  total <- percent.sub(data)
  mat <- NULL
  for(j in 1:nrow(data)) {
    # avoid dividing by zero
    if (total[j] != 0) {
      temp1 <- round(data[j,  ]/total[j] * 100, dig = 1)
    } else {
      temp1 <- data[j,]
    }
    mat <- rbind(mat, temp1)
  }
  dimnames(mat) <- list(dimnames(data)[[1]], dimnames(data)[[2]])
  mat
}

"percent.sub"<- function(conf)
{
  ## adds up the elements of the rows of a confusion matrix
  mat <- NULL
  for(j in 1:nrow(conf)) {
    mat <- c(mat, sum(conf[j,  ]))
  }
  mat
}

"perform" <- function(data)
{
  ## calculates total score in a confusion matrix, data
  k <- 0
  for(j in 1:nrow(data)) {
    k <- k + data[j, j]
  }
  total <- sum(data)
  wrong <- total - k
  correct <- (k/total) * 100
  wrong <- wrong/total * 100
  labcol <- c("correct %", "incorrect %")
  m <- cbind(correct, wrong)
  dimnames(m) <- list(NULL, labcol)
  m
}

# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"dapply"<- function(trackdata, fun, ...)
{
  ## data is a list as returned by track(), a vector
  ## or a matrix of data. Returns the output of fun for
  ## each segment in data
  ## fun must take a matrix or vector of data and an ftime
  ## vector and return an object with components $data and $ftime
  ## dapply must ensure that the resulting data component is
  ## still a matrix, even if the function returns a vector.

  if( version$major >= 5  && oldClass(trackdata)!="trackdata") {
      stop("argument to dapply is not of class trackdata.")
  } else if(class(trackdata)!="trackdata")
    stop("argument to dapply is not of class trackdata.")


  if(!is.matrix(trackdata$index)){
    trackdata$ftime <- rbind(trackdata$ftime)
    trackdata$index <- rbind(trackdata$index)
  }

  
  thisrow <- 1
  newindex <- trackdata$index
  newdata <- NULL
  newftime <- trackdata$ftime

  for(j in 1:nrow(trackdata$index)) {
    newindex[j,1] <- thisrow

    tmp <- fun(trackdata[j]$data, trackdata[j]$ftime, ...)

    if(is.matrix(tmp$data)){
      newdata <- rbind(newdata, tmp$data)
    } else {
      newdata <- c(newdata, tmp$data)
    }
    
    newftime[j,] <- tmp$ftime

    if(is.matrix(tmp$data))
      thisrow <- thisrow + nrow(tmp$data)
    else
      thisrow <- thisrow + length(tmp$data)
    newindex[j,2] <- thisrow - 1

  }

  x <- list(data=as.matrix(newdata), index=newindex, ftime=newftime)
  if( version$major >= 5 ) {
    oldClass(x) <- "trackdata"
  } else {
    class(x) <- "trackdata"
  }
  return(x)
}

"dmap"<- function(trackdata, fun, arg)
{
  ## a version of dapply which takes an additional
  ## argument which should be a vector/matrix
  ## with the same length/number of rows as the number of 
  ## segments in the trackdata.  One row of 'arg' is
  ## passed to 'fun' along with the data

  if( version$major >= 5  && oldClass(trackdata)!="trackdata") {
      stop("argument to dmap is not of class trackdata.")
  } else if(class(trackdata)!="trackdata")
    stop("argument to dapply is not of class trackdata.")

  if(!is.matrix(trackdata$index)){
    trackdata$ftime <- rbind(trackdata$ftime)
    trackdata$index <- rbind(trackdata$index)
  }

  thisrow <- 1
  newindex <- trackdata$index
  newdata <- NULL
  newftime <- trackdata$ftime

  for(j in 1:nrow(trackdata$index)) {
    newindex[j,1] <- thisrow

    if (is.matrix(arg)) {
      tmp <- fun(trackdata[j]$data, trackdata[j]$ftime, arg[j,])
    } else {
      tmp <- fun(trackdata[j]$data, trackdata[j]$ftime, arg[j])
    }

    if(is.matrix(tmp$data)){
      newdata <- rbind(newdata, tmp$data)
    } else {
      newdata <- c(newdata, tmp$data)
    }
    
    newftime[j,] <- tmp$ftime

    if(is.matrix(tmp$data))
      thisrow <- thisrow + nrow(tmp$data)
    else
      thisrow <- thisrow + length(tmp$data)
    newindex[j,2] <- thisrow - 1

  }

  x <- list(data=as.matrix(newdata), index=newindex, ftime=newftime)
  if( version$major >= 5 ) {
    oldClass(x) <- "trackdata"
  } else {
    class(x) <- "trackdata"
  }
  return(x)
}




"segdiff"<- function( data, ftime, n=1 )
{
  ## a function to be used with dapply()
  ## differentiates a segment n times returning
  ## the diff'd data and a new ftime pair

  if(is.matrix(data))
    datalength <- nrow(data)
  else
    datalength <- length(data)

  newdata <- apply( data, 2, diff, n )
  samp <- (ftime[2]-ftime[1])/datalength
  newftime <- c(ftime[1]+(n*samp/2), ftime[2]-(n*samp/2))
  return( list(data=newdata, ftime=newftime) )
}

ddiff <- function( trackdata, n=1 ) {
  return( dapply( trackdata, segdiff, n) )
}


"dapply.lab"<- function(data, labs, fun)
{
  ## data can be a list as returned by track(), a vector
  ## or a matrix of data. Returns the output of fun for
  ## each unique label in labs
  if(is.list(data)) {
    data <- data$data
    labs <- norm.sub(data$index, labs)
  }
  if( !is.matrix(data) ) data <- cbind(data)
  mat <- NULL
  for(j in unique(labs)) {
    temp <- labs == j
    vals <- data[temp,  ]
    if( !is.matrix(vals) ) vals <- cbind(vals)
    vecf <- apply(vals, 2, fun)
    mat <- rbind(mat, vecf)
  }
  dimnames(mat) <- list(unique(labs), NULL)
  mat
}

"norm.sub"<- function(indvals, labs)
{
  mat <- NULL
  for(j in 1:nrow(indvals)) {
    rightin <- indvals[j, 2]
    leftin <- indvals[j, 1]
    num <- rightin - leftin + 1
    vec <- rep(labs[j], num)
    mat <- c(mat, vec)
  }
  mat
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"dct" <-
function(wav, fit=F,  k=NULL)
{

if(!is.vector(wav) & !is.matrix(wav) )
stop("input signal must be a vector or a one-columned matrix")
if(is.matrix(wav) )
{
if(ncol(wav)!=1)
stop("input signal must be a vector or a one-columned matrix")
}
if(is.vector(wav))
nz <- names(wav)
if(is.matrix(wav))
nz <- dimnames(wav)[[1]]
N <- length(wav)
if(is.null(k))
k <- N
if(k < 2 | k > N)
stop("k must be between 2 and the length of the input signal")

# program begins here
wav <- c(wav, rev(wav[-c(1, N)]))
Nref <- length(wav)
coeff <- Re(fft(wav, inverse=T))/Nref

if(fit)
{
p <- 1:k
r <- c(Nref: (Nref-k+2))
p <- c(p, r)
coeff[-p] <- 0
coeff <- Re(fft(coeff, inverse=T))
}
coeff <-coeff[1:N]
names(coeff) <- nz
if(!fit)
coeff <- coeff[1:k]
coeff
}

"dct" <-
function(wav, fit=F,  k=NULL)
{

if(!is.vector(wav) & !is.matrix(wav) )
stop("input signal must be a vector or a one-columned matrix")
if(is.matrix(wav) )
{
if(ncol(wav)!=1)
stop("input signal must be a vector or a one-columned matrix")
}
if(is.vector(wav))
nz <- names(wav)
if(is.matrix(wav))
nz <- dimnames(wav)[[1]]
N <- length(wav)
if(is.null(k))
k <- N
if(k < 2 | k > N)
stop("k must be between 2 and the length of the input signal")

# program begins here
wav <- c(wav, rev(wav[-c(1, N)]))
Nref <- length(wav)
coeff <- Re(fft(wav, inverse=T))/Nref

if(fit)
{
p <- 1:k
r <- c(Nref: (Nref-k+2))
p <- c(p, r)
coeff[-p] <- 0
coeff <- Re(fft(coeff, inverse=T))
}
coeff <-coeff[1:N]
names(coeff) <- nz
if(!fit)
coeff <- coeff[1:k]
coeff
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2003 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

applyDCT <- function(trackdata, numOcoef=3, prop=1) {
  ## apply the DCT function to the data for each  segment
  ## in the trackdata object

  if( prop <= 0 || prop > 1 ) {
    stop("prop argument to applyDCT must be between 0 and 1")
  }

  # we're only interested in the data matrix since each segment
  # is transformed to a single row in  the result 
  return(dapply( trackdata, applyDCT.sub, numOcoef, prop )$data)
}


applyDCT.sub <- function( data, ftime, numOcoef, prop )  {
  ## apply the DCT function to one segment's worth of data
  ## conform  to the dapply  rules and return a list of
  ## new data and ftime

  ## data is a matrix of data
  ## ftime is a list of start/end times

  # only apply the transform to the proportion given  by prop
  rows <- nrow(data)
  data <- data[1:(rows*prop),]

  result <- NULL
  for(i in 1:ncol(data)) {
    result <- c(result, DCT(data[,i], inv=F)[1:numOcoef])
  }
  # generate an ftime vector corresponding  to the center of
  # the data
  time <- ftime[1] + prop*(ftime[2]-ftime[1])/2

  #  return  the appropriate structure
  return(list(data=matrix(result,nrow=1), ftime=c(time,time)))
}

DCT <- function(data, inv = T) {
  ##
  ## transform one - forward DCT
  ## this function calculates the discrete cosine transform of the time varying
  ## signal b_n
  ##
  ##                               N-1
  ##               G(k) = 2*e(n)/N*SUM b_n*cos[pi*(2k+1)*n/2N] k=0..N-1(3)
  ##                               n=0
  ## transform two - inverse DCT
  ## this function reconstructs a time domain waveform from the cosine
  ## waveform G(k), a smoothed version of the orginal b_n can be 
  ## obtained if less than  N-1 cosines are used.
  ## 
  ##                     N-1
  ##               b_n = SUM e(n)*G(k)*cos[pi*(2k+1)*n/2N] n=0..N-1(2)
  ##                     k=0
  ##
  ##
  ## where
  ##
  ##               e(n) = 1/sqrt(2) if n=0
  ##                    = 1, otherwize
  ## ref Discrete Cosine Transform by K.R. Rao and P. Yip
  ##

  ldat <- length(data)
  transdat <- vector(length = ldat)

  if(!inv) {
    ##  transform one
    transdat[1] <- (2/(ldat * sqrt(2))) * sum(data)
    for(n in 1:(ldat - 1)) {
      j <- 0:(ldat - 1)
      transdat[n + 1] <- (2/ldat) * sum(data *
                                        cos((pi * n * (2 * j + 1))/(2 * ldat)))
    }
  } else {
    ## transform two
    m <- 1:(ldat - 1)
    for(n in 0:(ldat - 1)) {
      transdat[n + 1] <- (1/sqrt(2)) * data[1] *
        cos((pi * 0 * (2 * n + 1))/(2 * ldat)) +
          sum( data[m + 1] * cos((pi * m * (2 * n + 1))/(2 * ldat)))
     
      ## I have checked this formula many times, just remember when
      ## the summation is done it is done for the nth sample of each
      ## of the m cosines with amplitudes data[m+1] 
    }
  }
  transdat
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"ddiff"<- function(dataset, n = 1, smoothing = T)
{
  ## differentiates a list, as returned by track, to the nth
  ## order, readjusting the index and ftime values each time
  ## dataset: a list as returned by track
  ## n: the order of differentiation

  ## now we apply the function to the data using dapply
  outdat <- dapply(dataset, ddiff.sub, n = n)
  if(smoothing)
    dsmooth(outdat)
    else outdat
}

ddiff.sub <- function(data, ftime, n)
{
  ## a function to be called by dapply
  ## data: a data matrix
  ## ftime: a start-end pair
  ## n: number of times to differentiate
  ## smoothing: if T, apply smooth to data too
  ## returns: a list of $data values differentiated 
  ## and $ftime values adjusted accordingly
  ## values in $data that are returned are per millisecond
  if(is.matrix(data)) lval <- nrow(data) else lval <- length(data
							     )
  if(lval < 1) stop("not enough data points in ddiff")	
  ## compute the time between samples
  interval <- (ftime[2] - ftime[1])/lval	
  ## do the differentiation
  data <- diff(data, differences = n)
  if(is.matrix(data))
    lval <- nrow(data)
    else lval <- length(data)
  timefactor <- (n * interval)/2
  ftime[1] <- ftime[1] + timefactor
  ftime[2] <- ftime[2] - timefactor	
  ## smooth the data as appropriate
  data <- data/interval	
  ## and return the data in the required format
  list(data = data, ftime = ftime)
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:


#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"dextract.lab"<- function(dataset, labs, labtype = unique(labs))
{
# extract data values from a dataset ($data, $index, $ftime)
# according to labtype (e.g. "i:", c("i:", "u:").
# labs is parallel to dataset$index; labtype are
# the label types for which the values in dataset are
# to be extracted
	mat <- NULL
	lvals <- dataset$index[, 2] - dataset$index[, 1] + 1
	newlabs <- rep(labs, lvals)
	temp <- muclass(newlabs, labtype)
	if(is.matrix(dataset$data))
	  vals <- dataset$data[temp,  ]
	else 
	  vals <- dataset$data[temp]

	temp.lab <- muclass(labs, labtype)

	if(!is.null(dataset$ftime))
	  ftimes <- dataset$ftime[temp.lab,  ]

	finds <- dataset$index[temp.lab,  ]	
	## readjust the indeces
	diffinds <- finds[, 2] - finds[, 1] + 1
	right <- cumsum(diffinds)
	first.left <- diffinds - 1
	left <- right - first.left
	finds <- cbind(left, right)
	mat$data <- vals
	mat$index <- finds
	if(!is.null(dataset$ftime))
	  mat$ftime <- ftimes
        if( version$major >= 5 ) {
          oldClass(mat) <- "trackdata"
        } else {
          class(mat) <- "trackdata"
        }
	mat
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

dextract <- function(dataset, start, end) {
  if((start < 0) | (start > 1)) {
    stop("proportional duration must be between 0 and 1")
  }
  if(!missing(end)) {
    if((end < 0) | (end > 1)) {
      stop("proportional duration must be between 0 and 1")
    }
    if(start > end) {
      stop("proportional start must be less than proportional end")
    }
  }

  if(missing(end)) {
    leftin <- dataset$index[, 1]
    rightin <- dataset$index[, 2]
    scalein <- round((rightin - leftin) * start)
    outin <- leftin + scalein
    if(is.matrix(dataset$data))
      return(dataset$data[outin,  ])
    else return(dataset$data[outin])
  } else {
    dapply(dataset, dextract.sub, start, end)
  }
}

# helper function for use via dapply, returns a new
# trackdata element cut at start/end proportions
dextract.sub <- function(data, ftime, start, end) {
  len <- nrow(data)
  start <- floor(start * len)
  end <- ceiling(end * len)
  newdata <- data[start:end,  ]
  times <- seq(ftime[1], ftime[2], length=len)
  newftime <- times[c(start,end)]
  return(list(data = newdata, ftime = newftime))
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"drecord" <- function(trackdata, segnum, time)
{
  ## returns the element in the frames data list
  ## that is referenced by segnum and time
  ftime <- trackdata$ftime
  indx <- trackdata$index

  if(!is.matrix(ftime)) ftime <- rbind(ftime)
  if(!is.matrix(indx)) indx <- rbind(indx)

  baserec <- indx[segnum, 1]
  endrec <- indx[segnum, 2]
  thisseg <- ftime[segnum,  ]
  percent <- (time - thisseg[1])/(thisseg[2] - thisseg[1])	
  
  return(as.integer(baserec + percent * (endrec - baserec)))
}

"frames.record" <- drecord

"frames.time" <- function(dataset, datanum)
{
  ## return the time and the number of the segment element
  ## that the datanum refers to
  if(is.matrix(dataset$ftime) == F) dataset$ftime <- rbind(dataset$ftime)
  if(is.matrix(dataset$index) == F)  dataset$index <- rbind(dataset$index)
  nums <- seq(1, nrow(dataset$ftime))
  incl <- dataset$index[, 1] <= datanum & dataset$index[, 2] >= datanum
  retv <- NULL
  segnum <- nums[incl]
  percent <- (datanum - dataset$index[segnum, 1])/
             (dataset$index[segnum, 2] - dataset$index[segnum, 1])
  retv$segnum <- segnum
  retv$time <- dataset$ftime[segnum, 1] + 
               percent * (dataset$ftime[segnum, 2] - dataset$ftime[segnum, 1])
  retv
}


"get.time.element"<- function(timeval, dataset)
{
  ## timeval: a time in milliseconds
  ## dataset: a data structure consisting of $data, $ftime, $index
  ## returns the element number of dataset$data corresponding to timeval
  numrows <- nrow(dataset$ftime)
  left <- dataset$ftime[1, 1]
  right <- dataset$ftime[numrows, 2]
  left.i <- dataset$index[1, 1]
  right.i <- dataset$index[numrows, 2]
  round(((timeval - left)/(right - left)) * (right.i - left.i)) + 1
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"dim.trackdata" <-
function(x)
{
# function returns the dimension attributes of
# a trackdata object as the number of segments x number of tracks
c(nrow(x$index), ncol(x$data))
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"dplot" <-
function (dataset, labs = NULL, offset = 0, ref.time = NULL, 
    average = F, main = "", xlab = "Time (ms)", ylab = "", xlim = NULL, 
    ylim = NULL, cex = 0.5, linetype = F, normalise = F, colour = T, 
    legend = "topright", axes = T, n = 20) 
{
    pout <- NULL
    if (is.matrix(dataset$data)) {
        pout <- as.list(NULL)
        pout$data <- as.list(NULL)
        mat <- NULL
        if (is.null(ylim)) 
            ylim <- range(dataset$data)
        numcols <- ncol(dataset$data)
        main <- c(rep("", numcols - 1), main)
        xlab <- c(rep("", numcols - 1), xlab)
        ylab <- c(rep("", numcols - 1), ylab)
        axes <- c(rep(F, numcols - 1), axes)
        for (j in 1:ncol(dataset$data)) {
            mat <- dataset
            mat$data <- mat$data[, j]
            if (!normalise) 
                vals <- dplot.time(mat, labs = labs, offset = offset, 
                  ref.time = ref.time, average = average, main = main[j], 
                  xlab = xlab[j], ylab = ylab[j], xlim = xlim, 
                  ylim = ylim, cex = cex, linetype = linetype, 
                  colour = colour, legend = legend, axes = axes[j])
            else vals <- dplot.norm(mat, labs = labs, average = average, 
                main = main[j], xlab = xlab[j], ylab = ylab[j], 
                xlim = xlim, ylim = ylim, cex = cex, linetype = linetype, 
                colour = colour, legend = legend, axes = axes[j], 
                n = n)
            par(new = T)
            pout$data[[j]] <- vals$data
            if (j == ncol(dataset$data)) {
                pout$time <- vals$time
                pout$labs <- vals$labs
            }
        }
    }
    else {
        if (!normalise) 
            pout <- dplot.time(dataset, labs = labs, offset = offset, 
                ref.time = ref.time, average = average, main = main, 
                xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, 
                cex = cex, linetype = linetype, colour = colour, 
                legend = legend, axes = axes)
        else pout <- dplot.norm(dataset, labs = labs, average = average, 
            main = main, xlab = xlab, ylab = ylab, xlim = xlim, 
            ylim = ylim, cex = cex, linetype = linetype, colour = colour, 
            legend = legend, axes = axes, n = n)
    }
    par(new = F)
    invisible(pout)
}



"dplot.time" <-
function (dataset, labs = NULL, offset = 0, ref.time = NULL, 
    average = F, main = "", xlab = "time (ms)", ylab = "", xlim = NULL, 
    ylim = NULL, cex = 0.5, linetype = F, colour = T, legend = "topright", 
    axes = T) 
{
    ovec <- as.list(NULL)
   
    samrate <- 1000/((dataset$ftime[1, 2] - dataset$ftime[1, 
        1])/(dataset$index[1, 2] - dataset$index[1, 1]))
    if ((offset < 0) | (offset > 1)) 
        stop("offset must be between 0 and 1")
    if (is.null(labs)) 
        labs <- rep(1, nrow(dataset$index))
    col.lty <- mu.colour(labs, colour, linetype)
    colour <- col.lty$colour
    linetype <- col.lty$linetype
    if (is.null(ref.time)) 
        ref.time <- dataset$ftime[, 1] + ((dataset$ftime[, 2] - 
            dataset$ftime[, 1]) * offset)
    maxlen <- 2 * (max(dataset$index[, 2] - dataset$index[, 1] + 
        1))
    pointval <- round(maxlen/2)
    mat.na <- matrix(NA, nrow(dataset$index), maxlen)
    for (j in 1:nrow(dataset$index)) {
        left <- dataset$index[j, 1]
        right <- dataset$index[j, 2]
        length.index <- right - left + 1
        times <- dataset$ftime[j, ]
        refn <- ref.time[j]
        inval <- closest(seq(times[1], times[2], length = length.index), 
            refn)
        inval <- inval[1]
        left.na <- pointval - inval + 1
        right.na <- left.na + length.index - 1
        mat.na[j, left.na:right.na] <- dataset$data[left:right]
    }
    z <- apply(mat.na, 2, mean, na.rm = T)
    natemp <- is.na(z)
    nums <- c(1:length(natemp))
    nonums <- nums[!natemp]
    interval <- 1000/samrate
    if (is.null(xlim)) 
        xlim <- c(nonums[1], nonums[length(nonums)])
    else xlim <- c(pointval + xlim[1]/interval, pointval + xlim[2]/interval)
    time1 <- (1 - pointval) * interval
    time2 <- (ncol(mat.na) - pointval) * interval
    xtime <- seq(time1, time2, length = ncol(mat.na))
    xtimelim <- (xlim - pointval) * interval
    if (is.null(ylim)) 
        ylim <- range(mat.na, na.rm = T)
    if (!average) {
        for (j in 1:nrow(mat.na)) {
            plot(xtime, mat.na[j, ], xlim = xtimelim, ylim = ylim, 
                xlab = "", ylab = "", axes = F, type = "l", col = colour[j], 
                lty = as.numeric(linetype[j]))
            par(new = T)
        }
        ovec$data <- mat.na
        ovec$time <- xtime
        ovec$labs <- labs
    }
    else {
        if (!is.null(labs)) {
            outmat <- NULL
            outlabs <- NULL
            for (j in unique(labs)) {
                temp <- labs == j
                vals <- mat.na[temp, ]
                if (is.matrix(vals)) {
                  mvals <- apply(vals, 2, mean, na.rm = T)
                }
                else {
                  mvals <- vals
                }
                outmat <- rbind(outmat, mvals)
                outlabs <- c(outlabs, j)
            }
        }
        else {
            outmat <- apply(mat.na, 2, mean, na.rm = T)
            outmat <- rbind(outmat)
            outlabs <- 1
        }
        col.code <- match(col.lty$legend$lab, unique(labs))
        colour <- col.lty$legend$col
        linetype <- col.lty$legend$lty
        for (j in 1:nrow(outmat)) {
            plot(xtime, outmat[j, ], xlim = xtimelim, ylim = ylim, 
                xlab = "", ylab = "", axes = F, type = "l", col = colour[col.code[j]], 
                lty = as.numeric(linetype[col.code[j]]))
            par(new = T)
        }
        ovec$data <- outmat
        ovec$time <- xtime
        ovec$labs <- outlabs
    }
    if (axes) {
        axis(side = 1, cex = cex)
        axis(side = 2, cex = cex)
        box()
    }
    title(main = main, xlab = xlab, ylab = ylab, cex = cex)
    
    if(is.logical(legend))
{
if(legend)
legend <- "topright"
        legend(legend, NULL, col.lty$legend$lab, col = col.lty$legend$col, 
            lty = as.numeric(col.lty$legend$lty), cex = cex)
}
else
legend(legend, NULL, col.lty$legend$lab, col = col.lty$legend$col, 
            lty = as.numeric(col.lty$legend$lty), cex = cex)

   
    invisible(ovec)
}



"dplot.norm" <-
function (dataset, labs = NULL, average = F, main = "", xlab = "time (ms)", 
    ylab = "", xlim = NULL, ylim = NULL, cex = 0.5, linetype = F, 
    colour = T, legend = "topright", axes = T, n = 20) 
{
    ovec <- NULL
    if (is.null(ylim)) 
        ylim <- range(dataset$data)
    if (is.null(xlim)) 
        xlim <- c(0, 1)
    if (is.null(labs)) {
        labs <- rep(1, nrow(dataset$index))
    }
    col.lty <- mu.colour(labs, colour, linetype)
    colour <- col.lty$colour
    linetype <- col.lty$linetype
    mat.na <- linear(dataset, n)
    mat.na$ftime <- dataset$ftime
    class(mat.na) <- "trackdata"
    xvec <- seq(0, 1, length = n)
    lval <- nrow(dataset$index)
    if (!average) {
        for (j in 1:lval) {
            plot(xvec, mat.na[j]$data, xlim = xlim, ylim = ylim, 
                xlab = "", ylab = "", axes = F, type = "l", col = colour[j], 
                lty = as.numeric(linetype[j]))
            par(new = T)
        }
        ovec$data <- mat.na
        ovec$time <- xvec
        ovec$labs <- labs
    }
    else {
        if (!is.null(labs)) {
            outmat <- NULL
            outlabs <- NULL
            for (j in unique(labs)) {
                temp <- labs == j
                vals <- mat.na[temp]$data
                vals <- matrix(vals, ncol = n, byrow = T)
                if (is.matrix(vals)) {
                  mvals <- apply(vals, 2, mean)
                }
                else {
                  mvals <- vals
                }
                outmat <- rbind(outmat, mvals)
                outlabs <- c(outlabs, j)
            }
        }
        else {
            outmat <- apply(matrix(mat.na, ncol = 20, byrow = T), 
                2, mean)
            outmat <- rbind(outmat)
            outlabs <- 1
        }
        col.code <- match(col.lty$legend$lab, unique(labs))
        colour <- col.lty$legend$col
        linetype <- col.lty$legend$lty
        for (j in 1:nrow(outmat)) {
            plot(xvec, outmat[j, ], xlim = xlim, ylim = ylim, 
                xlab = "", ylab = "", axes = F, type = "l", col = colour[col.code[j]], 
                lty = as.numeric(linetype[col.code[j]]))
            par(new = T)
        }
        ovec$data <- outmat
        ovec$time <- xvec
        ovec$labs <- labs
    }
    if (axes) {
        axis(side = 1, cex = cex)
        axis(side = 2, cex = cex)
        box()
    }
    title(main = main, xlab = xlab, ylab = ylab, cex = cex)
   if(is.logical(legend))
{
if(legend)
legend <- "topright"
        legend(legend, NULL, col.lty$legend$lab, col = col.lty$legend$col, 
            lty = as.numeric(col.lty$legend$lty), cex = cex)
}
else
legend(legend, NULL, col.lty$legend$lab, col = col.lty$legend$col, 
            lty = as.numeric(col.lty$legend$lty), cex = cex)

    invisible(ovec)
}
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################



"dshift" <- function(dataset, vec)
{
  ## subtracts a vector from the corresponding
  ## entry in dataset - a list as returned by track()
  lengths <- (dataset$index[, 2] - dataset$index[, 1]) + 1
  vals <- rep(vec, lengths)
  dataset$data <- dataset$data - vals
  dataset
}
 



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"dsmooth"<- function(dataset)
{
  ## dataset: a list, as returned by track
  ## separately smooths the segments corresponding to the data
  dapply(dataset, dsmooth.sub)
}


"dsmooth.sub" <- function(data, ftime)
{
  if(is.matrix(data)){
    if(nrow(data)>5)
      data <- apply(data, 2, smooth)
  } else {
    if(length(data)>5)
      data <- smooth(data)
  }
  return( list(data=data, ftime=ftime) )
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


dtime <- function(dataset, times, single = T, average = T) {
  if(!is.matrix(dataset$data))
    dataset$data <- cbind(dataset$data)

  if(!is.matrix(dataset$index)) {
    dataset$index <- rbind(dataset$index)
    dataset$ftime <- rbind(dataset$ftime)
  }

  mat <- NULL

  for(j in 1:length(times)) {
    left <- dataset$index[j, 1]
    right <- dataset$index[j, 2]
    dat <- dataset$data[left:right,  ]
    if(!is.matrix(dat))
      dat <- cbind(dat)
    lval <- right - left + 1
    left.time <- dataset$ftime[j, 1]
    right.time <- dataset$ftime[j, 2]
    seq.times <- seq(left.time, right.time, length = lval)
    cval <- closest(seq.times, times[j])
    if(single) {
      if(length(cval) > 1) {
        if(average) {
          cval <- mean(cval)
        }
        else {
          cval <- cval[1]
        }
      }
    }
    mat <- rbind(mat, dat[cval,  ])
  }

  if(ncol(mat) == 1) {
    c(mat)
  }
  else {
    mat
  }
}

"dcut"<- function(trackdata, left.time, right.time, single = T,
                  average = T, prop = F)
{
  ## trackdata: an object of class trackdata
  ## left.time: a vector of times which must be greater
  ## than trackdata$ftime[,1]
  ## right.time: a vector of times which must be less
  ## than trackdata$ftime[,2]
  ## if right.time is missing, then a vector or
  ## matrix of values are returned at left.time
  ## single: only applies if right.time is missing
  ## sometimes two values might be equitemporal
  ## between a left.time value, so if single is T
  ## only one of these is returned (see method below)
  ## average: only applies if right.time is missing and
  ## if single is T. If average is T and two
  ## values are equitemporal between a left.time value, 
  ## then the values are averaged; otherwise the first
  ## value is taken
  ## prop: if prop is T then left.time and right.time
  ## must be single valued vectors between 0 and 1
  ## For example, if prop = T and left.time is 0.25
  ## and right.time is 0.7, then trackdata is returned
  ## from time points corresponding to 25% of the duration
  ## into the trackdata to 70% of the duration into the
  ## trackdata. If right.time is missing and prop=T, then
  ## a vector or matrix is returned at a 
  ## time corresponding to 100 * left.time %. For example, 
  ## dcut(trackdata, 0.5, prop=T) extracts the values
  ## at the 50% time point
  ## 
  ##

  if(prop) {
    if(missing(right.time))
      omat <- dextract(trackdata, left.time)
    else
      omat <- dextract(trackdata, left.time, right.time)
  } else {
    if(missing(right.time))
      omat <- dtime(trackdata, left.time, single = single, 
                    average = average)
    else {
      if(length(left.time) != nrow(trackdata$ftime)) {
        stop( "different number of elements in left.time and $ftime")
      }
      if(length(right.time) != nrow(trackdata$ftime)) {
        stop("different number of elements in right.time and $ftime")
      }
      if(any(left.time < trackdata$ftime[, 1])) 
        stop("some left.time values are less than $ftime[,1]")

      if(any(right.time > trackdata$ftime[, 2])) 
        stop("some right.time values are greater than $ftime[,2]")

      if( any( right.time <= left.time ) ) 
        stop("some right.time values are before the corresponding left.time")

      lval <- nrow(trackdata$index)
      for(j in 1:lval) {
        tdat <- dcut.sub(trackdata[j], left.time[j], right.time[j])
        if(j == 1)
          omat <- tdat
        else
          omat <- bind(omat, tdat)
      }
    }
  }
  return(omat)
}

"dcut.sub" <- function(trackdata, left.time, right.time)
{
  vals <- trackdata$data
  left <- trackdata$ftime[1]
  right <- trackdata$ftime[2]

  if(is.matrix(vals))
    N <- nrow(vals)
  else
    N <- length(vals)
  
  times <- seq(left, right, length = N)
  first <- closest(times, left.time)

  if(length(first) > 1)
    first <- round(mean(first))

  second <- closest(times, right.time)

  if(length(second) > 1)
    second <- round(mean(second))

  if(is.matrix(vals))
    trackdata$data <- vals[first:second,  ]
  else
    trackdata$data <- cbind(vals[first:second]
                               )
  trackdata$ftime <- cbind(times[first], times[second])
  trackdata$index <- cbind(1, length(first:second))
  
  as.trackdata(trackdata$data, trackdata$index, trackdata$ftime)
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################



"read.emusegs"<- function(file)
{
  ## scan the lines of the file into a vector

  ## R 1.4 introduced comment.char="#" arg to scan, grrr
  if( is.R() && as.numeric(version$minor) > 3.0 ) {
    ## in R, we need to avoid skipping the # as a comment line
    lines <- scan(file, what = "", sep="\n", comment.char="")
  } else {
    lines <- scan(file, what = "", sep="\n")
  }

  # first three lines are header followed by a hash line
  inheader <- 1
  i <- 1
  labels <- start <- end <- utts <- NULL
  while( i < length(lines) && inheader) {
    if( lines[i] == "#" ) {
      inheader <- 0
    } else {
      foo <- splitstring( lines[i], ":" )
      if( foo[1] == "database" ) database <- paste(foo[-1], sep=":")
      if( foo[1] == "query" ) {
        query <- paste(foo[-1], sep=":")
      }
      if( foo[1] == "type" ) type <- paste(foo[-1], sep=":")
      i <- i + 1
    }
  }

  if (inheader) {
    stop( "End of header (#) not found in segment file" )
  }

  ## now slurp the body of the segment list
  mat <- matscan( file, 4, what="", sk=i )
  
  segs <- make.seglist(mat[,1], mat[,2], mat[,3], mat[,4], 
                     query, type, database )

  segs
}

if( version$major >= 5 ) {
  setOldClass(c("emusegs", "data.frame"))
}

make.seglist <- function(labels, start, end, utts, query, type, database)
{
  seglist <- data.frame(labels=I(as.character(labels)),
			start=as.numeric(start), 
			end=as.numeric(end), 
			utts=I(as.character(utts)))

  if( version$major >= 5 ) {
    oldClass(seglist) <- "emusegs"
  } else {
    class(seglist) <- c("emusegs", "data.frame")
  }

  attr(seglist, "query") <- query
  attr(seglist, "type") <- type
  attr(seglist, "database") <- database

  seglist
}

is.seglist <- function(object) {
  return( inherits(object, "emusegs") )
}

## modify a segment list by changing one or more of the fields
"modify.seglist" <- function( segs,
                             labels=label(segs),
                             start=mustart(segs),
                             end=muend(segs),
                             utts=utt(segs),
                             query=emusegs.query(segs),
                             type=emusegs.type(segs),
                             database=emusegs.database(segs))
{
  make.seglist( labels, start, end, utts,
               query, type, database )
}

"emusegs.database" <- function(sl) 
{ 
  if(is.seglist(sl))
    attr(sl, "database")
  else 
    stop( "not an emu segment list" )
}

"emusegs.type" <- function(sl) 
{ 
  if(is.seglist(sl))
    attr(sl, "type")
  else 
    stop( "not an emu segment list" )
}

"emusegs.query" <- function(sl) 
{ 
  if(is.seglist(sl))
    attr(sl, "query")
  else 
    stop( "not an emu segment list" )
}

"print.emusegs" <-  function(x, ...) 
{
  cat(attributes(x)$type, " list from database: ", attributes(x)$database, "\n")
  cat("query was: ", attributes(x)$query, "\n" )
  if( version$major >= 5 ) {
    oldClass(x) <- "data.frame"
  } else {
    class(x) <- "data.frame"
  }
  print.data.frame(x, ...)
}

"[.emusegs"<- function(segs,i,j)
{
  NextMethod("[",drop=F)
}

if( version$major >= 5 ) {
setMethod("[", "emusegs",
          function(x, i, j=1:ncol(x), drop = T)
          {
            if(missing(drop))
              "[.emusegs"(x, i,j)
            else
              "[.emusegs"(x, i,j)
          }
          )
}

"summary.emusegs" <- function(object, ...)
{
  cat(attributes(object)$type, " list from database: ", attributes(object)$database, "\n")
  cat("query was: ", attributes(object)$query, "\n" )
  cat(" with", length(object$start), "segments\n\n")
  cat("Segment distribution:\n")
  print(table(object$label))
  invisible()
}

"utt" <- function(segs) 
{
  segs$utts
}

"mustart" <- function(segs){
  as.numeric(segs$start)
}

"muend" <- function(segs){
  as.numeric(segs$end)
}

"mudur" <- function(segs)
{
  muend(segs) - mustart(segs)
}

"label" <- function(segs)
{
  segs$label
}

"as.matrix.emusegs" <- function(x)
{
  cbind( as.character(x$label), x$start, x$end, as.character(x$utt) )
}

"write.emusegs" <- function(seglist, file)
{
  cat(paste("database:", attributes(seglist)$database, "\n", sep=""), file=file)
  cat(paste("query:", attributes(seglist)$query, "\n", sep=""), file=file, append=T)
  cat(paste("type:", attributes(seglist)$type, "\n", sep=""), file=file, append=T)
  cat("#\n", file=file, append=T)
  write(t(as.matrix(seglist)), file, ncolumns = 4, append=T)
}


"bind.emusegs" <- function(...) 
{
  lists <- list(...)

  database <- emusegs.database(lists[[1]])
  type     <- emusegs.type(lists[[1]])
  query <- "compound"

  labels <- NULL
  starts <- NULL
  ends   <- NULL
  utts   <- NULL
  
  for( n in 1:length(lists)) {
    sl <- lists[[n]]
    if( emusegs.database(sl) != database )
      stop( "can't bind segment lists from different databases" )
    if( emusegs.type(sl) != type )
      stop( "can't bind segment lists and event lists together" )
    labels <- c(labels, label(sl))
    starts <- c(starts, mustart(sl))
    ends   <- c(ends, muend(sl))
    utts   <- c(utts, sl$utts)
  }
  make.seglist( labels, starts, ends, utts, query, type, database )
}


slen <- function(segs)
{
  ## find the length of a segment list
  nrow(segs)
}

# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:


#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"emu.inquotes" <- function( string ) {
  return( paste( "\"", string , "\"", sep="" ) )
}

"get.originalFreq" <- function (fname) {
  ##Original sampling frequency maybe stored at the top of the trackfile
  ##in this format: "# Original_Freq 20000"
  line <- readLines(fname, n=1)
  line <- splitstring(line, " ")
  if ((length(line) == 3) && (line[2] == "Original_Freq")) {
    origfreq <- as.numeric(line[3])
  } else {
    return(NULL)
  }
  if (origfreq > 0) {
    return(origfreq)
  } else {
    return(NULL)
  }
}

## construct a command line given a name and a list of arguments
## put quotes around the path since it may contain spaces on windows
"emu.command.name" <- function( name, ... )
{
  # first arg is command name
  command <- emu.inquotes( paste(emu.options("bindir"),
                                 emu.options("dirsep"),
                                 name,
                                 sep="" ) )
  arguments <- list(...)
  for( arg in arguments ) {
    command <- paste( command, arg, sep=" " )
  }
  return( command )
}



"emu.track"<- function( seglist, trackname,
                       cut=NULL, npoints=NULL,                       
		       template=attr(seglist, "database")) 
{
  if(emu.platform("MacOS")) {
    stop("emu.track is currently not implemented for MacOS. Use read.trackdata to read in data saved from the query tool.")
  }
  
  if( !inherits(seglist,"emusegs") ) 
    stop( "emu.track only works for emu segment/event lists" ) 

  if( is.null(template) ) 
    stop( "no template supplied and no default in segment list" )

  nseg <- nrow(seglist)

  segfile <- emu.tempfile( "emu.track" )
  resultfile <- emu.tempfile( "emu.track" )
  
  on.exit( unlink( segfile ), add=TRUE )
  on.exit( unlink( resultfile ), add=TRUE ) 
  
  write.emusegs( seglist, segfile )
  
  if(!missing(cut)) {
    cut <- paste( "-c", cut )
  } else {
    cut <- ""
  }

  if(!missing(npoints)) {
    npoints <- paste( "-n", npoints )
  } else {
    npoints <- ""
  }

  if (is.R()) {
    ## change to the template directory to make relative paths work
    currentwd <- getwd()
    ## this is a simple test to see whether template is a
    ## filename or just a database name
    if ( dirname(template) != "." ) {
      setwd(dirname(template))
    } else {
      setwd(dirname(emu.options("bindir")))
    }
  }
  command <- emu.command.name( emu.options("gettrack"),
                              cut,
                              npoints,
                              segfile, trackname, resultfile )

  opstat <- emu.system( command )

  if (is.R()) {
    ## return to the original wd
    setwd(currentwd)
  }

  if (!file.exists(resultfile) ) {
    ## give a suitable error message
    stop(paste("file ", resultfile, " doesn't exist in emu.track", sep=""))
  } 

  type <- attr(seglist, "type" )

  ## now read in the time/index data and the data 
  if(npoints == "" && (type == "event" || cut != "") ) {
    ## just read in the data and return it as a matrix
    result <- read.table( resultfile )
    if (ncol(result) > 1 ) {
      colnames <- paste(trackname, 1:ncol(result), sep="")
    } else {
      colnames <- trackname
    }
    # add some useful metadata to the return value
    # column and row names
#    dimnames(result)[[1]] <- label(seglist) 
    dimnames(result)[[2]] <- make.names(colnames)
    # changed return type to data.frame !
    # will this break scripts?
    origfreq <- get.originalFreq(resultfile)
    attr(result, "fs") <- origfreq
    return( result )
#    return( as.matrix(result) )
    
  } else {
    data <- read.trackdata( resultfile, trackname ) 
    origfreq <- get.originalFreq(resultfile)
    ## a bit of validation
    if( nrow(data$ftime) != nseg )
      stop( "error in emu.track: mismatch between number of segments and number of data items read" )
    attr(data,"fs") <- origfreq
    return( data )
  }
}

## read.trackdata
##  read data from two files into a trackdata object, the files
##  contain the data and time components of the object, they're
##  produced by gettrack and friends
##
##  Emu 1.7 introduces a new format for this data which can be stored
##  in one file. Try to be backward compatible by first looking
##  for one file as named and if not present falling back to the
##  two file version, now called read.trackdata.twofile
## 
## The new format is:
## segno time data data data
## segno time data data data
"read.trackdata" <- function (filename, trackname = "data") {

    if (!file.exists(filename)) {
        ## try the twofile version
        return(read.trackdata.twofile(filename, trackname))
    }
     ## otherwise we'll read the new file format
    data <- read.table(filename)
    
    ## now convert this to trackdata
    segnumbers <- data[, 1]
    times <- data[, 2]
    data <- data[, c(-1, -2)]
    
    data <- as.matrix(data)
    dimnames(data) <- list(times, paste("T", 1:ncol(data), sep=""))

    ## first check for the case of just one segment
    if (length(unique(segnumbers)) == 1) {
        ## get the start/end positions and times of the segment
        index <- cbind(start = 1, end = length(segnumbers))
        ftime <- cbind(start = times[1], end = times[length(times)])
    }
    else {
        ## get the start/end positions and times of each segment
        index <- cumsum(aggregate(data, by = list(segnum = segnumbers), FUN = length)[, 2])
        index <- cbind(start = c(1, index[1:(length(index) - 1)] + 1), end = index)
        ftime <- cbind(start = times[index[, 1]], end = times[index[,2]])
    }
    return(as.trackdata(data, index, ftime, trackname))
}



"read.trackdata.twofile" <- function( basename, trackname="data" ) {

  datname <- paste( basename, "dat", sep=".")
  timname <- paste( basename, "tim", sep=".")
  
  if (!file.exists(datname) || !file.exists(timname) ) {
    ## give a suitable error message
    stop(paste("Can't find data file ", basename, " or ", basename, ".dat/", basename, ".tim in read.trackdata", sep=""))
  } 

  data <- read.table( datname )
  index <- read.table( timname )
 
  # the number of segments is the number of rows in the index file
  nseg <- nrow( index )

  ## the sum of the first index column should correspond to
  ## the length of the data
  if( sum(index[,1]) != nrow( data ) ) 
    stop("error in emu.track: not enough data was read" )
  
  ## index[,1] is the lengths of every segment, convert to trackdata index 
  ## which is start and end point of every segment
  ## index[,2:3] is the ftime component of the trackdata object
  
  if (nseg == 1) {
    return( as.trackdata(as.matrix(data),
                        matrix(c(1,index[1,1]), nrow=1),
                        as.matrix(index[1,2:3]), 
                        trackname) )
  } else {
    return( as.trackdata(as.matrix(data),
                        cbind(c(1,cumsum(index[1:(nseg-1),1])+1), 
                              cumsum(index[,1])),
                        as.matrix(index[,2:3]), 
                        trackname))
  }
}


"write.trackdata" <- function(trackdata, file) {
   n <- 0:(nrow(trackdata$index)-1)
   indices <- rep(n, trackdata$index[,2]-trackdata$index[,1]+1)
   omat <- NULL

   for(j in 1:nrow(trackdata$ftime)){
      N <- trackdata$index[j,2]-trackdata$index[j,1]+1
      ftimes <- trackdata$ftime[j,]
      omat <- c(omat, seq(ftimes[1], ftimes[2], length=N))
   }

   result <- cbind(indices, omat, trackdata$data)
   write(t(result), file, ncolumns=ncol(result))
}



"emu.query" <- function(template, pattern=NULL, query="" )
{

  if(emu.platform("MacOS")) {
    stop("emu.query is currently not implemented for MacOS. Use read.emusegs to read in segment lists saved from the query tool.")
  }

  segfile <- emu.tempfile( "emu.query" )
	
  on.exit( unlink( segfile ) )

  command <- emu.command.name( "emuquery", "-o", segfile, template,
                              emu.inquotes( pattern ),
                              emu.inquotes( query ) )

  if (is.R()) {
    ## change to the template directory to make relative paths work
    currentwd <- getwd()
    ## this is a simple test to see whether template is a
    ## filename or just a database name
    if ( dirname(template) != "." ) {
      setwd(dirname(template))
    } else {
      setwd(dirname(emu.options("bindir")))
    }
  }
    emu.system( command )
    
  if (is.R()) {
    setwd(currentwd)
  }

  if (!file.exists(segfile) ) {
    ## give a suitable error message
    stop(paste("Can't find the query results in emu.query: there may have been a problem with the query command.", sep=""))
  } 

  result <- read.emusegs( segfile )

  attr(result, "template") <- template
  return(result)
}


"emu.requery" <- function(segs, level, targetlevel=level,
                          justlabels=F, sequence=0, longerok=F )
{
  segfile <- emu.tempfile( "emu.track" )
	
  write.emusegs( segs, segfile )

  on.exit( unlink( segfile ) )

  resultfile <- emu.tempfile( "emurequery" )
  on.exit( unlink( resultfile ) )

  options <- ""
  if (justlabels)
    options <- paste( options, "-j" )
  if (sequence != 0)
    options <- paste( options, "-s", sequence )
  if (longerok != 0)
    options <- paste( options, "-l" )

  command <- emu.command.name( "emurequery", "-o", resultfile, options,
                              segfile, level, targetlevel )

  if (is.R()) {
    template <- emusegs.database(segs)
    ## change to the template directory to make relative paths work
    currentwd <- getwd()
    ## this is a simple test to see whether template is a
    ## filename or just a database name
    if ( dirname(template) != "." ) {
      setwd(dirname(template))
    } else {
      setwd(dirname(emu.options("bindir")))
    }
  }
  
  emu.system( command )
  
  if (is.R()) {
    setwd(currentwd)
  }

    if (!file.exists(resultfile) ) {
    ## give a suitable error message
    stop(paste("Can't find the requery results in emu.requery: there may have been a problem with the query command.", sep=""))
  } 

  
  if (justlabels) 
    result <- scan( resultfile, what="" )
  else {
    result <- read.emusegs( resultfile )
  }

  return(result)
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"end.emusegs" <-
function(x)
{
as.numeric(x$end)
}

"end.trackdata" <-
function(x)
{
x$ftime[,2]
}

"epgai" <-
function(epgdata, weights = c(1, 9, 81, 729, 4921))
{
# function to calculate the anteriority index per palate
# as in Recasens & Pallares, 2001, 29, Jphon, p. 283, 
# epgdata: either a trackdata object or an array of type EPG
# or an 8 columned matrix or 8-element vector that's
# the output of dcut() applied to an EPG-trackdata object.

# weights: apply weights to rows 5, 4, 3, 2, 1.

# 
# returns: if p is a trackdata object, then
# the function returns trackdata of the
# same length as p with ant.index values.
# Otherwise, if p is an array of palates, 
# one value (the ant.index) per palate) is returned
#
if(!inherits(epgdata, "EPG")) p <- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
{
p <- array(p, c(8, 8, 1))
class(p) <- "EPG"
}
N <- dim(p)[3]
o <- epgsum(p, 1, rows=5:1)
w <- matrix(weights, nrow=N, ncol=5, byrow=T)
divisor <- matrix(c(rep(8, 4), 6), nrow=N, ncol=5, byrow=T)
num <- log(apply(w * o/divisor, 1, sum) + 1)
den <- log(sum(weights) + 1)
result <- cbind(num/den)
	if(is.trackdata(epgdata)) {
		epgdata$data <- result
		epgdata$trackname <- "anteriority"
	}
	else epgdata <- result
	epgdata
}

"epgci" <-
function(epgdata, weights = c(1, 11, 120, 1320))
{
# function to calculate the centrality index per palate
# as in the CCa formula in Recasens & Pallares, 2001, 29, Jphon, p. 283, 
# p: either a list of epg track
# data returned by track () or a three-dimensionsal array of palates
# weights: apply weights to columns 1 and 8;
# columns 2 and 7, columns 3 and 6, columns 4 and 5.

# 
# returns: if p is a list, then
# the function returns trackdata of the
# same length as p with ant.index values.
# Otherwise, if p is an array of palates, 
# one value (the ant.index) per palate) is returned
#
if(!inherits(epgdata, "EPG")) p <- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
{
p <- array(p, c(8, 8, 1))
class(p) <- "EPG"
}
N <- dim(p)[3]
num <- log((weights[1] * epgsum(p, columns=c(1,8))/8 +
weights[2] * epgsum(p, columns=c(2,7))/8 +
weights[3] * epgsum(p, columns=c(3,6))/8 +
weights[4] * epgsum(p, columns=c(4,5))/8) + 1)
den <- log(sum(weights) + 1)
result <- cbind(num/den)

if(is.trackdata(epgdata)) {
epgdata$data <- result
epgdata$trackname <- "anteriority"
}
else epgdata <- result
epgdata
}

"epgcog" <-
function(epgdata, weights = seq(7.5, 0.5, by = -1), rows=1:8, columns=1:8, row1 = NULL)
{
# function to calculate the centre of gravity per palate
# p: either a list of epg track
# data returned by track () or a three-dimensionsal array of palates
# weights: apply weights to rows 1..8.
# (defaults to 7.5, 6.5...0.5)
# row1: an optional numeric argument
# to allow a separate weighting of
# the electrodes in row1. For example, if row1=4/3, 
# then all the electrodes in row1 are multiplied by 
# that value, before the COG is calculated.
# Defaults to NULL (no weighting).
# 
# returns: if p is a list, then
# the function returns trackdata of the
# same length as p with COG values.
# Otherwise, if p is an array of palates, 
# one value (the COG) per palate) is returned
#
# gives the same result (0.5 and 1.17) as the 
# posterior COG measure  in Fig. 10.5, 
# Gibbon & Nicolaidis, 1999, p. 239,
# in Hardcastle & Hewlett Eds, 'Coarticulation'. CUP
# r = array(0, c(8, 8, 2))
# r[6,c(1, 8),1] = 1
# r[7,c(1, 2, 7, 8), 1] = 1
# r[8, ,1] = 1
# r[4, c(1, 2, 8), 2] = 1
# r[5, c(1, 2, 7, 8), 2] = 1
# r[6, c(1, 2, 3, 7, 8), 2] = 1
# r[7, , 2] = 1
# r[8, , 2] = 1
# epgcog(r, rows=5:8, columns=3:6)




weights <- weights[rows]
if(!inherits(epgdata, "EPG")) p <- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
{
p <- array(p, c(8, 8, 1))
class(p) <- "EPG"
}
N <- dim(p)[3]
if(!is.null(row1))
p[1,  ,  ] <- p[1,  ,  ] * row1
rowsum <- epgsum(p, 1, columns=columns)
w <- matrix(weights, nrow=N, ncol=8, byrow=T)
prodsum <- rowsum * w
prodsum <- rbind(prodsum[,rows])
sumval <- apply(prodsum, 1, sum)
psum <- epgsum(p, rows=rows, columns=columns)
# prevent division by zero
result <- rep(0, length(psum))
temp <- psum==0
result[!temp] <- sumval[!temp]/psum[!temp]
result <- cbind(result)
if(is.trackdata(epgdata)) {
epgdata$data <- result
epgdata$trackname <- "centre of gravity"
}
else epgdata <- result
epgdata
}

"epgdi" <-
function(epgdata)
{
# function to calculate the Qp, or
# dorsopalatal  index per palate
# as in Recasens & Pallares, 2001, 29, Jphon, p. 283, 
# p: either a list of epg track
# data returned by track () or a three-dimensionsal array of palates

# 
# returns: if p is a list, then
# the function returns trackdata of the
# same length as p with ant.index values.
# Otherwise, if p is an array of palates, 
# one value (the ant.index) per palate) is returned
#
if(!inherits(epgdata, "EPG")) p <- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
{
p <- array(p, c(8, 8, 1))
class(p) <- "EPG"
}
result <- cbind(epgsum(p, rows=6:8)/24)
if(is.trackdata(epgdata)) {
		epgdata$data <- result
		epgdata$trackname <- "dorsopalatal"
	}
	else epgdata <- result
	epgdata
}

"epggs" <-
function(epgdata, gscale=100, gridlines=T, gridcol="gray", gridlty=1, axes=T, xlab="", ylab="", ...)
{
# function to plot a 3D greyscale EPG imageb
# p is palate data, returned by palate() or EPG-trackdata
# plots greyscale image of contacts
# such that
# the darker the square, the greater the
# proportion of contacts. Thus a black square
# means that a contact was always on
# for all palatograms in p; a white
# square means that it was always off.

if(!inherits(epgdata, "EPG")) p <- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
{
p <- array(p, c(8, 8, 1))
class(p) <- "EPG"
}
n = dim(p)[3]
sump  = (apply(p, c(1,2), sum))/n 
image(1:8, 1:8, t(1-sump[8:1,]), col = gray(0:gscale/gscale), axes=F, xlab=xlab, ylab=ylab, ...)
if(axes)
{
axis(side=1)
axis(side=2, at=c(1, 3, 5, 7), lab=as.character(c(8, 6, 4, 2)))
}
if(gridlines)
grid(8, 8, col = gridcol, lty=gridlty)
}

"epgplot" <-
function(epgdata, select=NULL, numbering = "times", gridlines = T, mfrow = NULL, col = 1, mar=c(.8, .1, .8, .1), xlim=NULL)
{
# epgdata: a list as returned by emu.track()
# or else an array of palates. 
# numbering can be T or F or else a numeric or character vector
# which is equal in length to the number of palates)
# xlim: can only be used if epgdata are contiguous!
oldpar <- par()
# reset plot defaults on exit
on.exit(par(mfrow=oldpar$mfrow))

# set margin size
par(mar=mar)

# function to draw EPG-gridlines
epggrid <- function()
{
xgrid <- NULL
	for(j in 0:8) {
		vec <- c(j, j, NA)
		xgrid <- c(xgrid, vec)
	}
	ygrid <- rep(c(0, 8, NA), 9)	
ygrid[c(2,26)] <- 7
lines(xgrid, ygrid)
ygrid[25] <- 1
ygrid[2] <- 8
lines(ygrid, xgrid)
}


	if(!inherits(epgdata, "EPG")) epgdata <- palate(epgdata)


if(!is.null(select))
{
times <- dimnames(epgdata)[[3]]
smat <- NULL
for(j in select){
cl <- closest(as.numeric(times), j)[1]
smat <- c(smat, cl)
}
epgdata <- epgdata[,,smat]
}





	
	# the number of palates
	N <- dim(epgdata)
	if(length(N) == 2)
{
		N <- 1
epgdata <- array(epgdata, c(8, 8, 1))
}
	else N <- N[3]
times <- dimnames(epgdata)[[3]]
if(!is.null(xlim))
{
temp <- as.numeric(times) > xlim[1] & as.numeric(times) < xlim[2]
epgdata <- epgdata[,,temp]
times <- times[temp]
N <- sum(temp)
}
	if(is.logical(numbering)) {
		if(numbering)
			main <- as.character(1:N)
		else main <- rep("", N)
	}
	else if(length(numbering)==1)
{
if(numbering == "times")
main <- times
}
else
main <- as.character(numbering)
	x <- rep(0:7, rep(8, 8))
	xpoly <- cbind(x, x + 1, x + 1, x)
	y <- rep(7:0, 8)
	ypoly <- cbind(y, y, y + 1, y + 1)	# work out a sensible mfrow default
	if(is.null(mfrow)) {
		foo <- ceiling(sqrt(N))
		bar <- ceiling(N/foo)
		mfrow <- c(foo, bar)
	}

	epgplot.sub <- function(pgram, xpoly, ypoly, col = 1, main = "")
	{
		which <- c(pgram) == 1
		if(any(which)) {
# do nothing if the palate is empty
			xpoly <- xpoly[which,  ]
			ypoly <- ypoly[which,  ]	
	# silly hack to coerce a vector into a matrix
			xpoly <- rbind(xpoly)
			ypoly <- rbind(ypoly)
			mat <- NULL
			for(j in 1:sum(which)) {
				mat$x <- c(mat$x, c(xpoly[j,  ], NA))
				mat$y <- c(mat$y, c(ypoly[j,  ], NA))
			}
# remove last NA
			mat$x <- mat$x[ - length(mat$x)]
			mat$y <- mat$y[ - length(mat$y)]
		}
		plot(0:8, 0:8, type = "n", axes = F, xlab = "", ylab = "", main
			 = main)
		if(any(which))
			polygon(mat$x, mat$y, col = col)
	}
# plot the palatograms with a hack in case there's only one
	par(mfrow = mfrow)
	if(N > 1) {
		for(j in 1:N) {
			epgplot.sub(epgdata[,  , j], xpoly, ypoly, col = col, 
				main = main[j])
			if(gridlines) 
epggrid()
		}
	}
	else {
		epgplot.sub(epgdata, xpoly, ypoly, col = col, main = main)
		if(gridlines) 
epggrid()
	}
par(mar=oldpar$mar)
}

"epgsum" <-
function(epgdata, profile=c(1,3), inactive = F, rows=1:8, columns=1:8, trackname="EPG-sum")
{
# function  that sums by row or by column
# either the active or inactive electrodes of EPG-data.
# returns trackdata of the summed result.
# epgdata: epg data as returned by emu.track()
# allcontacts: if T, then all the contacts per palate are summed
# column: if T, then the summation is applied to
# columns, rather than to rows
# inactive: if T, then the summation is applied
# to the inactive (zero) electrodes, rather than to
# the active ones.
# 
k <- profile[1]
if(!inherits(epgdata, "EPG")) p<- palate(epgdata)
else p <- epgdata
# in case there is only one palate
if(length(dim(p) )==2)
p <- array(p, c(8, 8, 1))
if(length(rows) > 1 & length(columns) > 1)
p <- (p[rows, columns, ])
else 
p <- array(p[rows,columns,], c(length(rows), length(columns), dim(p)[3]))


# in case there is only one palate
if(length(dim(p) )==2)
p <- array(p, c(length(rows), length(columns), 1))
summation <- apply(p, c(k, 3), sum)
summation <- t(summation)
if(inactive) {
mat <- matrix(ncol(p), nrow = nrow(summation), ncol = ncol(summation)
)
summation <- mat - summation
}
if(length(profile)==2 & profile[2]==3)
summation <- apply(summation, 1, sum)
if(is.trackdata(epgdata))
result <- as.trackdata(summation, epgdata$index, epgdata$ftime, trackname)
else result <- summation
result
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

##########################################################################
"eplot" <-
function(data, labs, chars, formant = F, scaling = "linear", prob=.95, nsdev = NULL, 
	dopoints = F, doellipse = T, centroid = F, main = "", 
	xlab = "", ylab = "", axes = T, xlim, ylim, colour = T, linetype = F, 
	boundary = F, ...)
{
ocall <- match.call()
if(is.null(nsdev))
nsdev <- sqrt(qchisq(prob, 2))
	bplot <- function(data, labs, N = 10, xlim, ylim, metric = "bayes")
	{
		tdat <- train(data, labs)
		points <- cbind(sort(rep(1:N/N, N)), rep(1:N/N, N))
		points[, 1] <- points[, 1] * (xlim[2] - xlim[1]) + xlim[1]
		points[, 2] <- points[, 2] * (ylim[2] - ylim[1]) + ylim[1]
		blabs <- classify(points, tdat, metric = metric)
		ulabs <- unique(labs)
		k <- 1
		colours <- mu.colour(ulabs, T, F)$colour
		for(j in ulabs) {
			temp <- muclass(blabs, j)
			text(points[temp,  ], blabs[temp], col = colours[k])
			k <- k + 1
		}
	}
	if(missing(labs))
		labs <- rep(".", nrow(data))
	if(!doellipse & !dopoints)
		centroid <- T
	if(nrow(data) != length(labs))
		stop("Data and labels don't match")
	if(ncol(data) != 2)
		stop("Eplot needs 2 dimensional data")
	if(!missing(chars))
		if(length(labs) != length(chars))
			stop("Length of chars must match that of labs")
	if(scaling == "mel")
		data <- mel(data)
	if(scaling == "bark")
		data <- bark(data)
	if(formant)
{
		data <- cbind( - data[, 2],  - data[, 1])
if(!missing(xlim))
xlim <- -rev(xlim)
if(!missing(ylim))
ylim <- -rev(ylim)
}
	col.lty <- mu.colour(labs, colour, linetype)
	lty <- col.lty$linetype
	uniqlabels <- unique(labs)
	emat <- nums <- cen <- k <- l <- NULL
	for(j in uniqlabels) {
		temp <- labs == j
		mat <- data[temp,  , drop = F]
		if(nrow(mat) > 2) {
			evals <- eigen(var(mat))
			m1 <- mean(mat[, 1])
			m2 <- mean(mat[, 2])
			
			e <- ellipse(m1, m2, sqrt(evals$values[1]) * nsdev, 
				sqrt(evals$values[2]) * nsdev, aperm(evals$
				vectors, c(2, 1)))
		}
		else {
			cat("Too few data points for label ", j, 
				" will plot a point or a line\n")
			m1 <- mean(mat[, 1])
			m2 <- mean(mat[, 2])
			e <- mat
		}
		nums <- c(nums, nrow(e))
		emat <- rbind(emat, e)
		k <- c(k, col.lty$legend$col[match(j, col.lty$legend$lab)])
		l <- c(l, col.lty$legend$lty[match(j, col.lty$legend$lab)])
		if(centroid)
			cen <- rbind(cen, cbind(m1, m2))
	}
	if(doellipse) {
		if(missing(xlim))
			xlim <- range(c(emat[, 1], data[, 1]))
		if(missing(ylim))
			ylim <- range(c(emat[, 2], data[, 2]))
	}
	else {
		if(missing(xlim))
			xlim <- range(data[, 1])
		if(missing(ylim))
			ylim <- range(data[, 2])
	}
	rightlim <- cumsum(nums)
	leftlim <- cumsum(nums) - (nums - 1)
	rowmarker <- cbind(leftlim, rightlim)
	
	for(j in 1:nrow(rowmarker)) {
		lowerlim <- rowmarker[j, 1]
		upperlim <- rowmarker[j, 2]
		if(doellipse) {
			plot(emat[lowerlim:upperlim,  ], type = "l", axes = F, 
				xlim = xlim, ylim = ylim, col = k[j], xlab = "",
				ylab = "", lty = as.numeric(l[j]))
		}
		else {
			plot(emat[lowerlim:upperlim,  ], type = "n", axes = F, 
				xlim = xlim, ylim = ylim, col = k[j], xlab = "",
				ylab = "", lty = as.numeric(l[j]))
		}
		if(dopoints) {
centroid <- F
			singlelab <- uniqlabels[j]
			temp <- labs == singlelab
			if(!missing(chars))
				text(data[temp, 1], data[temp, 2], chars[temp], 
				  col = k[j])
			else text(data[temp, 1], data[temp, 2], labs[temp], col
				   = k[j])
		}
		if(centroid) {
			singlelab <- uniqlabels[j]
			text(cen[j, 1], cen[j, 2], singlelab, col = k[j])
		}
		if(j < nrow(rowmarker))
			par(new = T)
	}
	par(col = 1)
	box()
	if(axes) {
		if(formant) {
			if(missing(xlab))
				xlab <- "F2"
			if(missing(ylab))
				ylab <- "F1"
			xaxp <- par("xaxp")
			yaxp <- par("yaxp")
			xat <- seq(xaxp[1], xaxp[2], length.out = xaxp[3] + 1)
			yat <- seq(yaxp[1], yaxp[2], length.out = yaxp[3] + 1)
			axis(1, at = xat, label =  - xat)
			axis(2, at = yat, label =  - yat, srt = 90)
		}
		else {
			axis(1)
			axis(2)
		}
	}
	title(main = main, xlab = xlab, ylab = ylab)
	if(boundary) {
if(is.null(ocall$nboundary))
ocall$nboundary <- 50
		if(is.null(ocall$metric))
			ocall$metric <- "bayes"
		
		bplot(data, labs, N = ocall$nboundary, xlim = xlim, ylim = ylim, 
			metric = ocall$metric)
	}
}



"ellipse"<- function(x, y, rx, ry, orient, incr = 360/100)
{
	rincr <- radians(incr)
	theta <- seq(0, 2 * pi, rincr)
	xcoord <- rx * cos(theta)
	ycoord <- ry * sin(theta)
	mat <- cbind(xcoord, ycoord)
	mat <- mat %*% orient
	mat[, 1] <- mat[, 1] + x
	mat[, 2] <- mat[, 2] + y
	mat
}

"polygonplot" <- function(data, labels, order,
                          formant=T, axes=T,
                          xlab="", ylab="",
                          main = "", xlim, ylim)
{

  if( ncol(data) > 2 ) {
    data <- data[,1:2]
  }
  if( ncol(data) != 2 ) {
    error( "polygonplot() requires two columns of data" )
  }

  if(formant)
    data <- cbind(-data[, 2], -data[, 1])


  points <- NULL
  for( l in order ) {
    tmp <- matrix(data[labels==l],ncol=2)
    points <- rbind( points, apply(tmp, 2, mean) )
  }

  plot( points, type="b", pch=" ", axes=F, xlab="", ylab="" )
  text( points, order, axes=F, , xlab="", ylab="" )

  par(col = 1)
  box()
  if(axes) {
    if(formant) {
      if(missing(xlab))
	xlab <- "F2"
      if(missing(ylab))
	ylab <- "F1"
      xaxp <- par("xaxp")
      yaxp <- par("yaxp")
      xat <- seq(xaxp[1], xaxp[2], length.out = xaxp[3] + 1)
      yat <- seq(yaxp[1], yaxp[2], length.out = yaxp[3] + 1)
      axis(1, at = xat, label =  - xat)
      axis(2, at = yat, label =  - yat, srt = 90)
    }
    else {
      axis(1)
      axis(2)
    }
  }
  title(main = main, xlab = xlab, ylab = ylab)
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


library(mva)

"euclidean"<- function(data, m = 1, n = ncol(data))
{
  ## returns  a vector of Euclidean distances between adjacent
  ## pairs i.e. the Euclidean distance from data[1,] to
  ## data[2,], then data[3,] to data[4,] etc. data 
  ## must of course be a matrix of any number of dims
  ## It  makes use of the Splus program dist
  ## m and n are the columns of data over which the euclidean
  ## distances are to be calculated (defaults to all the columns)
  data <- data[, m:n]
  lengths <- nrow(data)
  downstep <- seq((lengths - 1), 2, -1)
  values <- c(1, 1 + cumsum(downstep))
  dist(data)[values]
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


".First.lib"<- function(thisdir, sectname)
{

  ## setup defaults 
  emu.init()

  if (interactive()) {
     cat("\nEMU Speech Database system \n",
         "Version ", emu.options("version"),
         "(C) SHLRC, Macquarie University, 1998\n\n")
  }
  
  ## call user's .First.emu if present

  if( exists(".First.emu") )
    do.call(".First.emu", list(paste(thisdir, sectname, sep="/")))
  
  invisible(TRUE)
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"hplot"<- function(vec, labs, xlab = "", ylab = "", main = "", 
                   colour = T, xlim = NULL, axes = T, legn="tl")
{
  ## written by Jonathan Harrington, 1992
  on.exit(par(new=F))

  if(missing(labs)) {
    legn <- F
    labs <- rep(".", length(vec))
  }

  len <- length(unique(labs))
  
  ## calculate the density, angle and colour vectors
  dens <- rep(30, len)  

  if(colour){
    col <- 1:len
    angle <- rep(45, len)
  }
  else{
    col <- rep(1, len)
    angle <- seq(45, 180, length = len)
  }

  mat <- NULL
  for(j in unique(labs)) {
    temp <- labs == j
    vals <- vec[temp]
    hvals <- hist(vals, plot = F)
    xvals <- hvals$breaks
    yvals <- hvals$counts
    xvals.d <- (diff(xvals)[1])/2
    xr1 <- c(xvals[1] - xvals.d, xvals[length(xvals)] + xvals.d)
    yr1 <- max(yvals)
    mat$y <- c(mat$y, yr1)
    mat$x <- c(mat$x, xr1)
    mat$diff <- c(mat$diff, xvals.d)
  }
  ylim <- c(0, max(mat$y) + (max(mat$y)/20))
  xlim <- range(mat$x)
  k <- 1
  lableg <- NULL
  for(j in unique(labs)) {
    temp <- labs == j
    vals <- vec[temp]
    hist(vals, xlab = "", ylab = "", main = "", col = col[k], xlim = 
	 xlim, ylim = ylim)
    lableg$lab <- c(lableg$lab, j)
    lableg$col <- c(lableg$col, col)
    lableg$angle <- c(lableg$angle, angle[k])
    k <- k + 1
    par(new = T)
  }
  if(legn!=F){
    legn <- mu.legend(legn, xlim, ylim)
    legend(legn$x, legn$y, legend = lableg$lab, 
	   col = lableg$col)
  }
  title(main = main, xlab = xlab, ylab = ylab, col = 1)
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"linear"<- function(dataset, n = 20)
{
  ## perform linear time normalisation of a data set as returned
  ## from track(), and including $data and $index
  outvals <- NULL
  if(!is.matrix(dataset$data))
    dataset$data <- cbind(dataset$data)
  for(j in 1:nrow(dataset$index)) {
    left <- dataset$index[j, 1]
    right <- dataset$index[j, 2]
    vec <- dataset$data[left:right,  ]
    if(!is.matrix(vec))
      vec <- cbind(vec)
    mat <- NULL
    for(k in 1:ncol(vec)) {
      linvec <- approx(vec[, k], n = n)
      mat <- cbind(mat, linvec$y)
    }
    outvals$data <- rbind(outvals$data, mat)
  }
  rightin <- seq(n, n * nrow(dataset$index), length = nrow(dataset$index))
  leftin <- rightin - n + 1
  outvals$index <- cbind(leftin, rightin)
  if(ncol(outvals$data) == 1)
    outvals$data <- c(outvals$data)
  outvals
}


"linear.av"<- function(dataset, labs)
{
  finmat <- NULL
  mat <- NULL
  if(!is.matrix(dataset$data))
    dataset$data <- cbind(dataset$data)
  for(j in 1:ncol(dataset$data)) {
    vec <- matrix(c(dataset$data[, j]), nrow(dataset$index), byrow
                  = T)
    outmat <- NULL
    for(k in unique(labs)) {
      temp <- labs == k
      labvec <- vec[temp,  ]
      outval <- apply(labvec, 2, mean)
      outmat <- c(outmat, outval)
    }
    mat <- cbind(mat, outmat)
  }
  tnum <- nrow(mat)
  tlab <- length(unique(labs))
  rightin <- seq(tnum/tlab, tnum, length = tlab)
  leftin <- rightin - (tnum/tlab) + 1
  finmat$data <- mat
  finmat$index <- cbind(leftin, rightin)
  finmat$lab <- unique(labs)
  finmat
}

# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"locus" <-
function (target, onset,  labels.vow=NULL, yxline=T, xlim = NULL, ylim = NULL, xlab="", ylab="", plotgraph=T) 
{
# target: vector of target freqs
# onset: vector of onset freqs
# labels.vow: optional vowel labels for plotting
# xlim, ylim: optional range for x and y-axes
# xlab, ylab: optional label for axes
# plot: if T, produces a plot of  target x  onset
# with a superimposed regression line through
# the scatter with superimposed line target = onset
# returns: statistical results of the fitting
# the regression line and the locus frequency in $locus
regr <- lm(onset ~ target)
mat <- rbind(cbind(1, -1), cbind(1, -regr$coef[2]))
vec <- c(0, regr$coef[1])
regr$locus <- ((solve(mat) %*% vec)[1])
if(plotgraph)
{
if(is.null(xlim))
xlim <- range(target)
if(is.null(ylim))
ylim <- range(onset)
if(is.null(labels.vow))
labels.vow <- rep("x", length(target))
plot(target, onset, xlim=xlim, ylim=ylim, xlab=xlab, ylab=ylab, type="n")
text(target, onset, labels.vow)
abline(regr)
if(yxline)
abline(0, 1, lty=2)
}

regr
}

"makelab" <-
function(vectimes,  uttname, dir, extn="xlab", labels=NULL)
# Function to write out ESPS label files
# One label file is written per element in uttname
# The resulting file is uttname.extn
# and it is written to the directory given by dir.
# vectimes:  a vector of times
# uttname: a character vector of the same length as vectimes
# giving the utterance name associated with each
# element of vectimes
# dir: a character specifying the directory
# extn: a character specifying the extension of the
# resulting files. Defaults to xlab
# labels:  if missing, each label written out
# has the label "x". Otherwise it can be a single
# element character vector such as "T" (each label
# then has the label "T") or else a vector of
# the same length as vectimes. 
# Example:

# s.vk <- emu.query("epg-demo", "*", "[Phoneme!=x -> Phoneme=k]")
# l.vk <- label(s.vk)
# e.vk <- emu.track(s.vk, "epg")
# e.dp <- dp(e.vk)
# maxzeit <- dmax(e.dp)
# labelfile(maxzeit[,1], utt(s.vk), "c:/d/test", "T")

{

if(is.null(labels))
labels <- rep("x", length(vectimes))
if(length(labels)==1)
labels <- rep(labels, length(vectimes))

ufun <- function(vectimes, uttname, labels, extn, dir)
{
a1 <- paste("signal", uttname)
a2 <- "nfields 1"
a3 <- "#"
omat <- cbind(vectimes/1000, rep(125, length(vectimes)), 
labels)
psort <- sort.list(vectimes/1000)
omat <- omat[psort,]


dirloc <- paste(paste(dir, uttname, sep="/"), extn, sep=".")
write(t(a1), dirloc)
write(t(a2), dirloc, append=T)
write(t(a3), dirloc, append=T)
write(t(omat), dirloc, ncol=3, append=T)

}


for(j in unique(uttname)){
temp <- uttname==j
ufun(vectimes[temp], j, labels[temp], extn, dir)
}

}

"[.EPG" <-
function (palates, i, j, k) 
{
    o <- NextMethod("[")
class(o) <- c("EPG")
o
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"mel" <- function(x)
{
	1/log(2) * (log(1 + (x/1000))) * 1000
}


"bark" <- function(f, inv=F) {
   # Convert Bark to Hz and vice-versa
   # Formulae in 
   # H. Traunmüller (1990) "Analytical expressions for the 
   # tonotopic sensory scale" J. Acoust. Soc. Am. 88: 97-100. 
   # f is a frequency in Hz unless inv=T,
   # in which case f is a frequency in Bark
   # inv: if T, performs Bark to Hz conversion
   if(!inv)
      result = ((26.81 * f) / (1960+f)) - 0.53
   else
      result = (1960 * (f + 0.53)) / (26.28 - f)
   result
}


#"bark" <- function(x)
#{
#  Hz <- x/1000
#  k1 <- (Hz/7.5) * (Hz/7.5)
#  (13 * (atan(0.76 * Hz))) + (3.5 * (atan(k1)))
#}

"zwicker"<-
structure(.Data = c(10, 100, 200, 300, 395, 510, 630, 765, 920, 1075, 1265, 
	1480, 1710, 1990, 2310, 2675, 3125, 3650, 4350, 5250, 6350, 7600, 9250, 
	11750, 90, 200, 300, 400, 505, 630, 770, 915, 1080, 1265, 1475, 1720, 
	1990, 2310, 2690, 3125, 3675, 4350, 5250, 6350, 7650, 9400, 11750, 
	15250), .Dim = c(24, 2))




## return the index of the value in vec which is closest to val
"closest" <- function(vec, val)
{
	newval <- min(abs((vec - val)))
	z <- abs(vec - val)
	temp <- z == newval
	nums <- c(1:length(vec))
	nums[temp]
}

"hamming" <- function(pts = 512)
{
  vec <- 0:(pts-1)
  0.54 - 0.46 * cos((2 * pi * vec)/(pts-1))
}

"label.num" <- function(labs)
{
  ## labs: a vector of labels
  ## convert labels to integers
  qq <- unique(labs)
  nums <- c(1:length(qq))
  for(j in 1:length(qq)) {
    temp <- labs == qq[j]
    labs[temp] <- nums[j]
  }
  as.numeric(labs)
}


## label.convert --
##  map one set of labels to another in a segment
##  list or label vector
##
"label.convert" <- function(segs.or.labels, match, replace)
{
  if (is.seglist( segs.or.labels ) ) {
    labs <- label(segs.or.labels)
  } else {
    labs <- segs.or.labels
  }
  if( length(match) != length(replace) ) {
    ## this is only ok if length(replace) == 1 so that we
    ## replace anything in match with replace
    if( length(replace) != 1 ) {
      stop("Lengths of match and replace vectors differ in label.convert")
    } 
  }

  if (length(replace) == 1) {
    temp <- muclass(labs, match)
    labs[temp] <- replace
  } else {
    for( i in 1:length(match) ) {
      labs[labs==match[i]] <- replace[i]
    }
  }
  if (is.seglist(segs.or.labels)) {
    return( modify.seglist(segs.or.labels, label=labs))
  } else {
    return( labs )
  }
}


"matscan"<- function(file, num.cols=count.fields(file)[1], what = 0, sk = 0)
{
  ## first make a template, a list of num.cols what's
  template <- as.list(rep(what, num.cols))
  data <- scan(file, template, skip=sk,quote = "")
  num.rows <- length(data[[1]])
  mat <- matrix(0, num.rows, num.cols)
  for(i in 1:num.cols) {
    mat[, i] <- data[[i]]
  }
  mat
}



"muclass"<- function(labels, class)
{
  !(is.na(match(labels, class)))
}

"randomise.segs" <-  function( segs, rand = T, bwd=F )
{
  if( bwd ){
    ## reverse the segment list
    segs[slen(segs):1,]
  } else {
    ## randomise the segment list
    segs[sample(1:slen(segs)),]
  }
}

"radians"<- function(degrees) (degrees * 2 * pi)/360

"sortmatrix" <- function(mat, labs = dimnames(mat)[[2]])
{
  ## labs can also be a vector of labels, which has
  ## the same number of columns as mat; e.g.
  ## if labs is "p" "t" "k", then mat
  ## will be sorted with these three labels in the first
  ## three columns
	b1 <- labs
	b2 <- dimnames(mat)[[1]]
	c1 <- match(b2, b1)
	d1 <- cbind(c1, mat)
	newmat <- d1[sort.list(d1[, 1]),  ]
	newmat <- newmat[, -1]
	b1 <- dimnames(newmat)[[1]]
	b2 <- dimnames(newmat)[[2]]
	c1 <- match(b2, b1)
	d1 <- rbind(c1, newmat)
	newmat2 <- d1[, (sort.list(d1[1,  ],  ))]
	newmat2[-1,  ]
}


"splitmat"<- function(data, labs, filename = "file", labelfile = T)
{
# data: a vector or matrix of data; labs a parallel label
# file. Creates a new 
#  series of objects called obj.n etc. where n is an
# integer from 1 to n number of phonetic classes
# if labelfile is T, then a parallel label file is created
# called l.file.n
	newmat <- NULL
	labelfile <- NULL
	labelname <- NULL
	k <- 1
	if(!is.matrix(data))
		data <- rbind(data)
	for(j in unique(labs)) {
          temp <- muclass(labs, j)
          newdata <- data[temp,  ]
          outlab <- paste(filename, k, sep = ".")
          l.outlab <- paste("l.", outlab, sep = "")
          assign(outlab, newdata, w = 1)
          assign(l.outlab, rep(j, sum(temp)), w = 1)
          labelname <- c(labelname, j)
          newmat <- c(newmat, outlab)
          labelfile <- c(labelfile, l.outlab)
          k <- k + 1
	}
	z <- cbind(newmat, labelfile, labelname)
	headlabs <- c("filename", "label-file", "label-type")
	dimnames(z) <- list(NULL, headlabs)
	z
}


if( is.R() ) {

  splitstring <- function(str, char)  {
    return(strsplit(str, char)[[1]])
  }

} else {

splitstring <- function(str,char) {
  if(str == "")
    mat <- c(str)
  else {
    mat <- NULL
    ind <- 1
    cont <- T
    while(T) {
      ministr <- NULL
      length <- 0
      while(T) {
	ch <- substring(str, ind, ind)
	if(ch == char) {
	  ind <- ind + 1
	  break
	}
	if(ch == "") {
	  break
	}
	ministr <- c(ministr, ch)
	ind <- ind + 1
	length <- length + 1
      }
      ## now concatenate string
      if(length > 0)
	mat <- c(mat, paste(ministr, collapse = ""))
      if(ch == "")
	break
    }
  }
  mat
}

}

"uttnum"<- function(utt, str)
{
  temp <- muclass(utt, str)
  nums <- c(1:length(utt))
  nums[temp]
}

# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

"mu.colour"<- function( labs, col, linetype, defaultcolour=1 )
{
  ## Generate a colour and line type vector for 
  ## one of the mu+ plots
  ## col and linetype can be either T, F or a vector 
  ## if they are F then the corresponding return element
  ## is a vector of 1's of length len
  ## if they are T then the corresponding return element
  ## is a vector of different numbers, length len
  ## if either is a vector then it is converted to a 
  ## numeric vector with a different integer per unique label 

  ## if col is a vector of length 2*length(unique(labs)) then
  ## it should be a set of pairs {label, number} and number
  ## will be assigned to label in the resulting list
  
  len <- length(labs)
    ulen <- length(unique(labs))
    if (length(col) == 2 * ulen) {
        colours <- 1:len
        n <- 1
        while (n <= ulen) {
            lab <- col[2 * n - 1]
            colour <- col[2 * n]
            colours[labs == lab] <- as.numeric(colour)
            n <- n + 1
        }
        col <- colours
    }
    else if (is.numeric(col)) {
if(length(col)==1)
col <- rep(col, len)
else{
        if (length(col) != length(labs)) 
            stop("length of colour vector differs from that of labels")
}
    }
    else if (!is.logical(col)) {
        col <- 1:length(unique(col))
        if (length(col) != length(labs)) 
            stop("length of colour vector differs from that of labels")
    }
    else {
        if (col) {
            colours <- 1:ulen
            col <- labs
            ulabels <- unique(labs)
            for (i in 1:len) {
                col[i] <- colours[ulabels == labs[i]]
            }
        }
        else {
            col <- rep(defaultcolour, len)
        }
    }
    if (!is.logical(linetype)) {
        if (length(linetype) == 1) 
            linetype <- rep(linetype, len)
        else linetype <- 1:length(unique(linetype))
        if (length(linetype) != length(labs)) 
            stop("length of linetype vector differs from that of labels")
    }
    else {
        if (linetype) {
            lty <- 1:ulen
            linetype <- labs
            ulabels <- unique(labs)
            for (i in 1:len) {
                linetype[i] <- lty[ulabels == labs[i]]
            }
        }
        else {
            linetype <- rep(1, len)
        }
    }
    foo <- NULL
    foo$colour <- col
    foo$linetype <- linetype
    p1 <- paste(labs, col, linetype)
    p1.temp <- duplicated(p1)
    foo$legend$lab <- labs[!p1.temp]
    foo$legend$col <- foo$colour[!p1.temp]
    foo$legend$lty <- foo$linetype[!p1.temp]
    return(foo)
}

## return the colour for a given label via the colour object
mu.colour.get <- function(col.lty, label) {

  colour <- col.lty$legend$col[match(label, col.lty$legend$lab)]
  return( colour )

}

mu.linetype.get <- function(col.lty, label) {

  lty <- col.lty$legend$lty[match(label, col.lty$legend$lab)]
  return( lty )

}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

"mu.legend"<- function(legn, xlim, ylim)
{
  fudge.x <- (xlim[2]-xlim[1])/5
  fudge.y <- (ylim[2]-ylim[1])/5
  if(legn=="tl")
    return(list(x=xlim[1], y=ylim[2]))
  if(legn=="tr")
    return(list(x=xlim[2]-fudge.x, y=ylim[2]))
  if(legn=="br")
    return(list(x=xlim[2]-fudge.x, y=ylim[1]+fudge.y))
  if(legn=="bl")
    return(list(x=xlim[1], y=ylim[1]+fudge.y))
  if(legn=="loc")
    return(locator(1))
  stop("Unknown legend locator in mu.legend")
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"norm"<- function(data, speakerlabs, type = "gerst", rescale = F)
{
  ## data: a matrix of data. Can be
  ## an n-columned matrix or a list as returned by track()
  ## speakerlabs, a parallel
  ## vector of speaker labels
  ## type: which normalisation do you want?
  ## type can be "nearey", "cen", "lob", "gerst" (default)
  ## for normalisation according to Nearey, centroid method
  ## Lobanov, Gerstman.
  ## rescale: do you want to rescale? 
  ## for all normalisations except nearey, rescaling works by factoring
  ## in the corresponding data across all talkers - e.g. for
  ## lobanov, s and m, the standard deviation and mean
  ## are calculated across all talkers; the lobanov
  ## normalised data are then multiplied by s to which m is added;
  ## for nearey, the normalised values are rescaled linearly
  ## in the ranges of the parameters across all the talkers; 
  ## e.g. if the range on the first parameter across all talkers
  ## is 200 to 1000, then the first nearey-scaled parameter
  ## is rescaled linearly within this range
  flag <- F
  if(is.list(data)) {
    flag <- T
    indvals <- data$index
    tvals <- data$ftime
    speakerlabs <- expand.labels(indvals, speakerlabs)
    data <- data$data
  }
  if(!is.matrix(data))
    data <- cbind(data)
  if(rescale) {
    if(type == "lob") {
      mvals <- apply(data, 2, mean)
      sdvals <- sqrt(apply(data, 2, var))
    }
    if(type == "nearey")
      neardata <- data
    if(type == "gerst") {
      mind <- apply(data, 2, min)
      maxd <- apply(data, 2, max)
      ranged <- maxd - mind
    }
  }
  if(type == "cen")
    cendata <- data
  for(j in unique(speakerlabs)) {
    temp <- speakerlabs == j
    vals <- data[temp,  ]
    if(type == "gerst")
      nvals <- gerst.sub(vals)
      else if(type == "lob")
	nvals <- lob.sub(vals)
	else if(type == "nearey")
	  nvals <- nearey.sub(vals)
	  else if(type == "cen")
	    nvals <- cen.sub(vals)
    data[temp,  ] <- nvals
  }
  if(rescale) {
    if(type == "lob")
      data <- rescale.lob(data, mvals, sdvals)
    if(type == "nearey")
      data <- rescale.nearey(data, neardata)
    if(type == "gerst")
      data <- rescale.gerst(data, mind, ranged)
    if(type == "cen")
      data <- rescale.cen(data, cendata)
  }
  if(flag) {
    vec <- data
    data <- NULL
    data$data <- vec
    data$index <- indvals
    data$ftime <- tvals
  }
  data
}

"gerst.sub"<- function(data)
{
  minvals <- apply(data, 2, min)
  maxvals <- apply(data, 2, max)
  rvals <- maxvals - minvals
  vec1 <- rep(minvals, nrow(data))
  vecmat <- matrix(vec1, nrow(data), byrow = T)
  rvec1 <- rep(rvals, nrow(data))
  rvecmat <- matrix(rvec1, nrow(data), byrow = T)
  (data - vecmat)/rvecmat
}

"lob.sub"<- function(data)
{
  if(!is.matrix(data))
    data <- cbind(data)
  meanvals <- apply(data, 2, mean)
  rvals <- sqrt(apply(data, 2, var))
  vec1 <- rep(meanvals, nrow(data))
  vecmat <- matrix(vec1, nrow(data), byrow = T)
  rvec1 <- rep(rvals, nrow(data))
  rvecmat <- matrix(rvec1, nrow(data), byrow = T)
  (data - vecmat)/rvecmat
}


"nearey.sub"<- function(data)
{
  if(!is.matrix(data))
    data <- cbind(data)
  ldata <- log(data)
  meanvals <- apply(ldata, 2, mean)
  tmean <- mean(meanvals)
  ldata - tmean
}

"cen.sub"<- function(data)
{
  if(!is.matrix(data))
    data <- cbind(data)
  mat <- NULL
  meanvals <- apply(data, 2, mean)
  for(j in 1:ncol(data)) {
    newdat <- data[, j] - meanvals[j]
    mat <- cbind(mat, newdat)
  }
  mat
}

"expand.labels"<- function(indvals, labs)
{
  ## indvals is the index component returned by frames/track
  ## labs is the parallel label vector
  ## returns a vector of labels, one for each row in the data matrix
  ## that corresponds to indvals
  mat <- NULL
  for(j in 1:nrow(indvals)) {
    rightin <- indvals[j, 2]
    leftin <- indvals[j, 1]
    num <- rightin - leftin + 1
    vec <- rep(labs[j], num)
    mat <- c(mat, vec)
  }
  mat
}


"rescale.lob"<- function(data, mvals, sdvals)
{
# rescales the Lobanov normalised data. mvals is the
# mean of the raw data, sdvals the standard dev. of
# the raw data
	if(!is.matrix(data)) data <- mvals + (data * sdvals) else mat <- NULL
	{
		for(j in 1:ncol(data)) {
			vec <- data[, j] * sdvals[j]
			mvec <- vec + mvals[j]
			mat <- cbind(mat, mvec)
		}
	}
	mat
}


"rescale.gerst"<- function(data, mind, ranged)
{
	for(j in 1:ncol(data)) {
		data[, j] <- data[, j] * ranged[j] + mind[j]
	}
	data
}



"rescale.nearey"<- function(data, neardata)
{
	if(!is.matrix(data))
		data <- rbind(data)
	for(j in 1:ncol(data)) {
		rval <- max(neardata[, j]) - min(neardata[, j])
		mindata <- min(data[, j])
		maxdata <- max(data[, j])
		rangedata <- maxdata - mindata
		data[, j] <- min(neardata[, j]) + 
		  (((data[, j] - mindata)/rangedata) * rval)
	}
	data
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"nplot"<- function(values, labs=NULL, xlab = "", ylab = "probability density", 
                   main = "", colour=T, linetype=F, plot.lab = T, xlim = NULL)
{
  ## values: a vector of parameter values
  ## labs: parallel labels
  if(is.null(labs)){
    plot.lab <- F
    labs <- rep(1, length(values))}
  col.lty <- mu.colour(unique(labs), colour, linetype)
  colour <- col.lty$colour
  lty <- col.lty$linetype

  vals.norm <- NULL
  newlab <- NULL
  for(j in unique(labs)) {
    temp <- muclass(labs, j)
    vec1 <- values[temp]
    meanvals <- mean(vec1)
    sdvals <- sqrt(var(vec1))
    normvals <- dnorm(vec1, meanvals, sdvals)
    dat1 <- cbind(vec1, normvals)
    vals.norm <- rbind(vals.norm, dat1[sort.list(dat1[, 1]),  ])
    newlab <- c(newlab, rep(j, sum(temp)))
  }
  
  if(is.null(xlim))
    xrange <- range(vals.norm[, 1])
  else xrange <- xlim

  yrange <- range(vals.norm[, 2])

  k <- 1
  for(j in unique(newlab)) {
    temp <- muclass(newlab, j)
    plot(vals.norm[temp,  ], type = "l", axes = F, xlab = "", ylab
	 = "", col = colour[k], xlim = xrange, ylim = yrange, lty
	 = lty[k])
    if(plot.lab) {
      mtext(j, line = 0.1, side = 3, at = mean(vals.norm[temp, 
				     1]), col = colour[k])
    }
    k <- k + 1
    par(new = T)
  }
  axis(1)
  axis(2)
  box()
  title(main = main, ylab = ylab, xlab = xlab)
  par(new = F)
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

"outliers" <-  function(data, labels, threshold) {
    model <- train(data,labels)
    dist <- distance(data, model, labels, metric="mahal")
    good <- NULL
    bad  <- NULL
    ddd  <- NULL
    for(n in 1:length(model$label)){
      l <- model$label[n]
      which <- labels==l
      dd <- dist[which, n]
      meandd <- mean(dd)
      sdevdd <- sqrt(var(dd))

      cutoff <- sdevdd*threshold

      idx <- (1:length(labels))[which]
      tmp <- idx[dd<cutoff]
      good <- c(good, tmp)
      tmp <- idx[dd>=cutoff]
      bad  <- c(bad, tmp )
      ddd <- c(ddd, dist[which,n] )
    }
    list(good=good[!is.na(good)], bad=bad[!is.na(bad)], dist=ddd)
  }
"palate" <-
function(epgdata)
{
# epgdata: either a vector of length 8 or
# a matrix of ncol = 8 with 1 row per segment
# or trackdata. If it's trackdata, then the
# result returned is applied to epgdata$data
if(is.trackdata(epgdata))
epgdata <- epgdata$data
times <- dimnames(epgdata)[[1]]
	if(!is.matrix(epgdata)) epgdata <- rbind(epgdata)
	if(ncol(epgdata) != 8) {
		print("input must have 8 columns or be a vector of length 8")
		stop()
	}
	bingen <- function(n = 8)
	{
# n is the number of columns in the result
		mat <- NULL
		x <- 2^(0:(n - 1))
		vec <- rev(x)
		for(j in length(vec):1) {
			res <- rep(c(rep(0, x[j]), rep(1, x[j])), vec[j])
			mat <- cbind(mat, res)
		}
		mat
	}
	nsegs <- nrow(epgdata)
	epgdata <- c(t(epgdata))
	epgdata <- epgdata + 1
	p <- bingen()
	p <- p[epgdata,  ]
	amat <- array(t(p), c(8, 8, nsegs))
if(nsegs > 1)
	p <- aperm(amat[8:1, 8:1,  ], c(2, 1, 3))
# usual silly annoying hack in case there's only one palatogram
else
{
v <- amat[8:1, 8:1,  ]
v <- array(v, c(8, 8, 1))
p <- aperm(v, c(2, 1, 3))
}
 
charrow <- paste("R", 1:8, sep="")
charcol <- paste("C", 1:8, sep="")
dimnames(p) <- list(charrow, charcol, times)
class(p) <- c("array", "EPG")
p
}

"plafit" <-
function(wav,fit=F, n=101)
{
if(!is.vector(wav) & !is.matrix(wav) )
stop("input signal must be a vector or a one-columned matrix")
if(is.matrix(wav) )
{
if(ncol(wav)!=1)
stop("input signal must be a vector or a one-columned matrix")
}
if(is.vector(wav))
nz <- names(wav)
if(is.matrix(wav))
nz <- dimnames(wav)[[1]]
if(n %% 2 != 1)
n <- n + 1
N <- length(wav)
a <- approx(wav, n=n)$y
times <- seq(-1, 1, length=n)
c0 <- a[times==0]
c1 <- 0.5 * (a[n] - a[1])
c2 <- 0.5 * (a[n] + a[1]) - c0
if(fit)
{
y <- c0 + c1 * times + c2 * (times^2)
result <- approx(y, n=N)$y
names(result) <- nz
}
else
{
result <- c(c0, c1, c2)
names(result) <- c("c0", "c1", "c2")
}
result
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


## play fn using the c-coded play written for xlispstat
## and hopefully compatible with Splus/R

"play"<- function(playdata, rate )
{
  datarange <- range(playdata)

  ## scale to 8 bits
  playdata <- 256*(playdata - datarange[1])/(datarange[2] - datarange[1])
  
  invisible(.C("xlplay",
               as.integer(playdata),
               as.integer(length(playdata)),
               as.integer(rate)))
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"rbind.trackdata" <-
function (...) 
{
    mat <- NULL
    for (j in list(...)) {
        if (is.matrix(j$data)) 
            mat$data <- rbind(mat$data, j$data)
        else mat$data <- c(mat$data, j$data)
        mat$index <- rbind(mat$index, j$index)
        if (!is.null(j$ftime)) 
            mat$ftime <- rbind(mat$ftime, j$ftime)
    }
    diffinds <- mat$index[, 2] - mat$index[, 1] + 1
    right <- cumsum(diffinds)
    first.left <- diffinds - 1
    left <- right - first.left
    mat$index <- cbind(left, right)
    if (version$major >= 5) {
        oldClass(mat) <- "trackdata"
    }
    else {
        class(mat) <- "trackdata"
    }
    mat
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################



"segplot"<- function(segs, param, labels, ylim, data, ylab = "",
                     main = "", zeros = F, pdat = 0.5,
                     onset = 0, offset = 0, colour = T,
                     linetype=F, smoothing = F, mfrow, addlines=NULL,
                     differ=NULL)
{
  ## written by Jonathan Harrington, 1992
  if(!is.null(addlines)){
    if(is.matrix(addlines))
      lval.a <- nrow(addlines)
    else
      lval.a <- length(addlines)
    if(is.matrix(segs))
      lval.s <- nrow(segs)
    else
      lval.s <- 1
    if(lval.a!=lval.s)
      stop("number of entries in the segment list and addlines do not match")
  }
#  oldpar<-par()
#  on.exit(par(oldpar))
  oldsegs <- segs
  if(missing(labels)) labels <- label(segs)
  if(!is.matrix(oldsegs)) oldsegs <- rbind(oldsegs)
  if(missing(data)) {
    ## adjust the segment times to include onset and offset
    ## this could maybe an option in emu.track since we can't ensure 
    ## here that there is real data at these times
    segs <- make.seglist(labels,
                         mustart(segs) - onset, 
                         muend(segs) + offset, 
                         utt(segs),
                         emusegs.query(segs),
                         emusegs.type(segs),
                         emusegs.database(segs))
    
    values <- emu.track(segs, param)
  } else {
    values <- data
  }
  
  if(!is.null(differ))
    values <- ddiff(values, differ)
  if(smoothing)
    values <- dsmooth(values)
  if(!is.matrix(values$data)) values$data <- cbind(values$data)

  if(zeros) {
    ## this assumes that there is a prob_voice track, eg from ESPS
    pvoice <- emu.track(segs, "prob_voice")$data
    temp <- pvoice > pdat
    values$data[!temp,  ] <- NA
  }

  if(missing(ylim)) ylim <- range(values$data, na.rm = T)

  ## work out a sensible mfrow default
  if(missing(mfrow)){
    nsegs <- nrow(segs)
    foo <- ceiling(sqrt(nsegs))
    bar <- ceiling(nsegs/foo)
    mfrow <- c(foo, bar)
    
  }
  par(mfrow = mfrow)
  if(!colour)
    labcol <- 1
  else
    labcol <- 7
  tempf <- c(1: ncol(values$data))
  col.lty <- mu.colour(tempf, colour, linetype)
  if(colour)
    col.lty$colour <- col.lty$colour+1
  colour <- col.lty$colour
  lty <- col.lty$linetype

  for(j in 1:nrow(segs)) {
    midtimes <- (mustart(oldsegs[j,  ]) + muend(oldsegs[j,  ]))/2
    boundtimes <- c(mustart(oldsegs[j,  ]), muend(oldsegs[j,  ]))
    plab <- labels[j]
    if(is.null(plab)) plab <- ""
    index.left <- values$index[j, 1]
    index.right <- values$index[j, 2]
    data <- values$data[index.left:index.right,  ]
    if(!is.matrix(data)) data <- cbind(data)
    left.time <- values$ftime[j, 1]
    right.time <- values$ftime[j, 2]
    timevals <- seq(left.time, right.time, length = nrow(data))
    rtimes <- range(c(boundtimes, timevals))

    for(k in 1:ncol(data)) {
      plot(timevals, data[, k], xlim = rtimes, ylim = ylim, 
	   xlab = "", ylab = "", main = "", xaxt = "n", yaxt="n",
	   col=colour[k], lty=lty[k], type = "l")
      par(new = T)
    }
    abline(v = boundtimes, lty = 2, col = labcol)
    if(!is.null(addlines)){
      if(!is.matrix(addlines))
	addlines <- cbind(addlines)
      for(i in 1:ncol(addlines)){
	abline(v=addlines[j,i], col=labcol)
      }}
    mtext(plab, side = 3, line = 1, at = midtimes, col = labcol)
    title(main = main, ylab = ylab, xlab = "time (ms)", xaxt = "s", yaxt="s")
    par(new = F )
    
  }
  par(mfrow=c(1,1))
  invisible()
}


## Local Variables:
## mode:S
## S-temp-buffer-p:t
## End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

"Slope.test" <- function(...)
{
  ## compiled by Jonathan Harrington and Marija Tabain (October 1997)
  ## this function tests whether the intercepts and slopes
  ## of two or more (straight-line) regressions are significantly
  ## different
  ## matrices are to be compared on slope and intercept;
  ## arrange y in col 1, x in col 2 in each case.
  ## see E. Pedhazur, Multiple Regression in Behavioral Research
  ## p.436-450, 496-507. 
  Slope.sub <- function(...)
    {
      ## combine the matrices, and find out how many rows there are altogether
      omat <- NULL
      omat$numcats <- length(list(...))
      for(j in list(...)) {
	numrows <- nrow(j)
	omat$y <- c(omat$y, j[, 1])
	omat$x <- c(omat$x, j[, 2])
	omat$numrows <- c(omat$numrows, numrows)
      }
      ## set up category vectors of 1, 0, 0, .... -1
      vec <- rep(0, omat$numcats - 1)
      omat$mat <- NULL
      for(j in 1:length(vec)) {
	zeros <- vec
	zeros[j] <- 1
	zeros <- c(zeros, -1)
	zeros <- rep(zeros, omat$numrows)
	omat$mat <- cbind(omat$mat, zeros)
      }
      omat
    }

  ## main function begins here
  omat <- Slope.sub(...)	
  ## number of category vectors and the (1) continuous vector for intercept
  k1 <- omat$numcats	# the (1) continuous vector for intercept
  k2 <- 1	        # number of category vectors, product 
                        # vectors and (1)continuous vector 

  ## for slope
  k3 <- 1 + ((omat$numcats - 1) * 2)	
  ## number of category vectors and (1) continuous vector for slope
  k4 <- omat$numcats	## length of y and of x
  N <- sum(omat$numrows)

  for(j in list(...)) {
    ## find the F-ratio, degrees of freedom, r-squared values, slope and intercept
    ## for the separate matrices
    firstvals <- summary.lm(lm(j[, 1] ~ j[, 2]))
    first.pf <- pf(firstvals$fstatistic[1], firstvals$fstatistic[2],
		   firstvals$fstatistic[3])
    first.out <- c(firstvals$r.squared, firstvals$fstatistic, 
		   first.pf, firstvals$coefficients[, 1])
    omat$separate <- rbind(omat$separate, first.out)
  }

  dimnames(omat$separate)[[2]] <- c("r-sq", "F ratio", "df", "df", 
				    "prob. line fits data", "intercept", "slope")	

  ## multiply the category vectors by the x-values 
  prodvals <- omat$x * omat$mat
  z123 <- lm(omat$y ~ omat$x + omat$mat + prodvals)
  z12 <- lm(omat$y ~ omat$x + omat$mat)
  z2 <- lm(omat$y ~ omat$x)	## r-squared vals
  r12 <- summary.lm(z12)$r.squared
  r2 <- summary.lm(z2)$r.squared	## F-ratios
  fval.in.num <- (r12 - r2)/(k1 - k2)
  fval.in.den <- (1 - r12)/(N - k1 - 1)
  fratio.in <- fval.in.num/fval.in.den
  s123 <- summary.aov(z123)
  fratio.slope <- s123$"F Value"[3]	

  ## calculate probabilities and degrees of freedom
  prob.in <- pf(fratio.in, k1 - k2, N - k1 - 1)
  prob.slope <- pf(fratio.slope, k3 - k4, N - k3 - 1)
  first <- c(fratio.in, prob.in, k1 - k2, N - k1 - 1)
  second <- c(fratio.slope, prob.slope, k3 - k4, N - k3 - 1)
  outtemp <- rbind(first, second)
  col.lab <- c("intercept", "slope")
  row.lab <- c("F ratio", "Probability of them being DIFFERENT", "df", 
	       "df")
  dimnames(outtemp) <- list(col.lab, row.lab)
  omat$combined <- outtemp
  omat
}
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"spectplot" <- function(segs, track = "samples",  bandwidth="w",
			psfile="", rate=20000, scale=5, height=7,
			frange=c(0,rate/2),rms=F,
			ncolors=16, factor=4.0, zeropt=35,
			smoothformants=F,
                  	formants="fm", ...)
{
  makespec <- paste(emu.options("bindir"), "makespec", 
	            sep=emu.options("dirsep"))

  tmpfile <- emu.tempfile("spec")
  template <- attributes(segs)$database
  uttname <- utt(segs[1,])
  start <- mustart(segs)[1]
  end <- muend(segs)[nrow(segs)]

  command <- paste( makespec, template, 
		   start/1000, end/1000, uttname, bandwidth,
 		   frange[1], frange[2], factor, zeropt,  "> ", tmpfile)
  exitscript <- ""
  exitscript <- paste( exitscript, "unlink(", tmpfile , ");", sep="")
  cat(command)
  emu.system(command)


  spec <- as.matrix(read.table( tmpfile ))
  sgram.width <- dim(spec)[2]

  ## there is a bug giving a fake line at the top of the sgram and
  ## an artifact at the bottom, cut them off here
  spec <- spec[,6:sgram.width-1]
  # and modify the frange accordingly
  tmp <- frange[2]-frange[1]
  frange <- c( frange[1]+(6/sgram.width)*tmp, frange[2]-(1/sgram.width)*tmp )


  if( psfile != ""){
    ps.options(rasters=600)
    ps.options(image.colors=0:ncolors/ncolors) 
    ps.options(colors=c(0.0, 0.6, 0.3, 0.9, 0.4, 0.7, 0.1, 0.5, 0.8, 0.2) ) 
    setps(psfile, w=scale*sum(mudur(segs))/1000, h=height, type="char")
  }

  ## set bottom margin to zero on the gui plot
  oldmai <- par("mai")
  exitscript <- paste( exitscript, "par(mai=", oldmai , ");", sep="")
  mai <- oldmai
  mai[1] <- 0
  par(mai=mai)

  ## this needs to come here since the par() call above needs to happen
  ## before dev.off()
  if( psfile != "") 
      exitscript <- paste( exitscript, "dev.off();", sep="")
  on.exit( exitscript )
  
  frame()
  
  if( rms ) {
    par(fig=c(0,1,0.8,1))
    uttplot(segs, "rms", xlab="", colour=F, axes=F)
    box()

    mai <- oldmai
    mai[1] <- 0
    mai[3] <- 0
    par(mai=mai)
    fig <- c(0,1,0.3,0.8)
    formdolabels <- F
  } else {
    fig <- c(0,1,0.3,1)
    formdolabels <- T
  }

  par(fig=fig)
  if (is.R()) {
    image(z=spec, axes=F, col=gray(1:16/16))
  } else {
    image(spec, axes=F)
  }
  par(new=T)
  uttplot(segs, formants, ylim=frange, xlab="", zeros=T,ylab="frequency (Hz)",
	  defcolour=0, colour=F, axes=F, dolabels=formdolabels, 
	  smoothing=smoothformants)
  axis(2)
  box()
  par(new=T)
  mai <- oldmai
  mai[3] <- 0
  par(mai=mai)
  par(fig=c(0,1,0,0.3))
  uttplot(segs, track, colour=F, dolabels=F,axes=F,...)
  axis(1)
  box()

  par(fig=c(0,1,0,1))
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"start.emusegs" <-
function(x)
{
as.numeric(x$start)
}

"start.trackdata" <-
function(x)
{
x$ftime[,1]
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

"steady"<- function(values, percent = 25, cumulative = F, meanv = T,
                    leftlim = NULL, rightlim = NULL, smoothing = F)
{
  ## leftlim, rightlim. can be between 0 and 1; e.g. to constrain
  ## the target to be found in the first 30% of the syllable, set
  ## leftlim to 0, rightlim to 30
  lval <- values$index[, 2] - values$index[, 1] + 1
  frlength <- round((lval * percent)/100)
  values$index.old <- values$index
  if(!is.null(leftlim))
    values$index[, 1] <- steady.int(values, leftlim)
  if(!is.null(rightlim))
    values$index[, 2] <- steady.int(values, rightlim)
  if(smoothing)
    values <- dsmooth(values)
  addvals <- values$index[, 1] - 1
  for(j in 1:nrow(values$index)) {
    newdata <- values$data[((values$index[j, 1]):(values$index[j, 2])),  ]
    numframes <- frlength[j]
    distvals <- euclidean(newdata)
    sumvals <- steady.step(distvals, frlength[j])
    temp <- sumvals == min(sumvals)
    nums <- c(1:length(sumvals))
    minno <- nums[temp]
    vec <- c(minno, minno + (numframes - 1))
    vec <- vec + addvals[j]
    if(meanv) {
      sdata <- rbind(values$data[((vec[1]):(vec[2])),  ])
      meanvals <- apply(sdata, 2, mean)
      values$mean <- rbind(values$mean, meanvals)
      values$inds <- rbind(values$inds, vec)
    }
    values$steady <- rbind(values$steady, vec)
  }
  midval <- (values$steady[, 2] + values$steady[, 1])/2
  numval <- midval - values$index.old[, 1]
  denval <- values$index.old[, 2] - values$index.old[, 1]
  values$time <- numval/denval	
  ## calculate the times of the left and right target boundaries
  smat <- NULL
  smat$index <- values$index.old
  smat$ftime <- values$ftime
  left.time <- steady.time(values$inds[, 1], smat)
  right.time <- steady.time(values$inds[, 2], smat)
  values$stime <- cbind(left.time, right.time)
  if( version$major >= 5 ) {
    oldClass(values) <- NULL
  } else {
    class(values) <- NULL
  }
  values
}


"steady.int"<- function(dataset, cut)
{
  ## returns the index number corresponding to cut
  leftin <- dataset$index[, 1]
  rightin <- dataset$index[, 2]
  scalein <- (rightin - leftin) * cut
  round(leftin + scalein)
}


"steady.step"<-
  function(vec, nframes)
{
  ## this function takes a vector and adds up frames 1 to n
  ## then 2 to n+1 then 3 to n + 2 etc. The value of n 
  ## is specified by nframes - for example if the length
  ## of the vector is 10 and nframes is 3, 
  ##  the frames that are added are 1:4, 2:5, 3:6, 4:7, 5:8, 
  ## 6:9, 7:10.
  m <- nframes - 1
  mat <- NULL
  for(k in 1:(length(vec) - m)) {
    mat <- c(mat, sum(vec[k:(k + m)]))
  }
  mat
}


"steady.plot"<- function(values, vec, labs = NULL, ylim = NULL,
                         col = 1, main = "")
{
  ## values - the ouput from Steady
  tlen <- length(vec)
  if(tlen > 20) {
    print("maximum of 20 segments allowed")
    break()
  }
  else if(tlen <= 5)
    pict <- c(1, 5)
  else if((tlen > 5) & (tlen <= 10))
    pict <- c(2, 5)
  else if((tlen > 10) & (tlen <= 15))
    pict <- c(3, 5)
  else pict <- c(4, 5)
  par(mfrow = pict)
  decum <- values$index[, 1] - 1
  decum <- cbind(decum, decum)
  values$steady <- values$steady - decum
  values$index <- values$index[vec,  ]
  values$index <- rbind(values$index)
  values$steady <- values$steady[vec,  ]
  values$steady <- rbind(values$steady)
  for(j in 1:nrow(values$index)) {
    leftid <- values$index[j, 1]
    rightid <- values$index[j, 2]
    data <- values$data[leftid:rightid,  ]
    if(any(ylim) == F)
      ylim <- range(data)
    notap <- rep(NA, ncol(data))
    newdata <- rbind(data, notap)
    datay <- c(newdata)
    nums <- c(1:nrow(data))
    nums <- c(nums, NA)
    datax <- rep(nums, ncol(data))
    datay1 <- datay[.Uminus(length(datay))]
    datax1 <- datax[.Uminus(length(datax))]
    plot(datax1, datay1, type = "l", xlab = "Number of frames", 
         ylab = "Frequency (Hz)", ylim = ylim, col = col, main
         = main)
    abline(v = values$steady[j, 1], lty = 2)
    abline(v = values$steady[j, 2], lty = 2)
    if(any(labs)) {
      mtext(labs[j], side = 3, line = 1, at = mean(c(values$
                                           index[j, 1], values$index[j, 2])))
    }
  }
  invisible()
}


"steady.time"<- function(ind, vals)
{
  ## calculates the time corresponding to ind1, based
  ## on vals$index and vals$ftime 
  ## inds must be the same length as nrow(vals$index)
  leftind <- vals$index[, 1]
  rightind <- vals$index[, 2]
  rangeind <- rightind - leftind
  left.time <- vals$ftime[, 1]
  right.time <- vals$ftime[, 2]
  range.time <- right.time - left.time
  (((ind - leftind)/rangeind) * (range.time)) + left.time
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"utt.talk"<- function(utt.dat, internalspeaker = F)
{
# interactive playback on any waveform produced with
# uttplot with talk=T. left button twice to define
# the interval, middle button to quit
# example: mu.sub37a
# written by Jonathan Harrington, 1992
  
  samrate <- utt.dat$samrate

  cat("Use left mouse button to define left and right boundaries\n")
  cat("To quit, click on the middle mouse button\n")


  repeat {
    times.a <- locator(1)
    if(!any(times.a$x)) break
    abline(v = times.a$x)
    times.b <- locator(1)
    abline(v = times.b$x)
    if(times.a$x[1] < utt.dat$ftime[1, 1])
      left <- 1
    else 
      left <- round((times.a$x[1] - utt.dat$ftime[1, 1])/(1000/samrate)) + 1

    if(times.b$x[1] > utt.dat$ftime[nrow(utt.dat$ftime), 2])
      right <- length(utt.dat$data)
    else 
      right <- round((times.b$x[1] - utt.dat$ftime[1, 1])/(1000/samrate)) + 1

    play(utt.dat$data[left:right], samrate, internalspeaker = internalspeaker)
    abline(v = times.a$x, col = 0)
    abline(v = times.b$x, col = 0)
    box()
    invisible()
  }
}

# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
"-.trackdata" <-
function(x, y)
{
# function for doing arithmetic on trackdata objects
# see +.trackdata for examples

if(class(x)=="trackdata")
{
ftime <- x$ftime
inds <- x$index
nm <- x$name
}
else
{
ftime <- y$ftime
inds <- y$index
nm <- y$name
}

if(class(x)=="trackdata" & class(y)=="trackdata")
o <- x$data - y$data
else if (class(x)=="trackdata" & class(y)!="trackdata")
o <- x$data - y
else if (class(x)!="trackdata" & class(y)=="trackdata")
o <- x - y$data
as.trackdata(o, inds, ftime, nm)
}

"+.trackdata" <-
function(x, y)
{
# function for doing arithmetic on trackdata objects
# examples
# z = vowlax.fdat[,1]+vowlax.fdat[,2]
# same
# sum(z$data - (vowlax.fdat[,1]$data +vowlax.fdat[,2]$data))


# z = vowlax.fdat[,1]+vowlax.fdat[,2]+vowlax.fdat[,3]
# same
#sum(z$data - (vowlax.fdat[,1]$data +vowlax.fdat[,2]$data+vowlax.fdat[,3]$data))


# z = vowlax.fdat[,1]+20
# same
# sum(z$data -  (vowlax.fdat[,1]$data + 20))


# z = 20 + vowlax.fdat[,1] + 30 + vowlax.fdat[,2]
# same
# sum(z$data -  (20+vowlax.fdat[,1]$data + 30+vowlax.fdat[,2]$data))

if(class(x)=="trackdata")
{
ftime <- x$ftime
inds <- x$index
nm <- x$name
}
else
{
ftime <- y$ftime
inds <- y$index
nm <- y$name
}


if(class(x)=="trackdata" & class(y)=="trackdata")
o <- x$data + y$data
else if (class(x)=="trackdata" & class(y)!="trackdata")
o <- x$data + y
else if (class(x)!="trackdata" & class(y)=="trackdata")
o <- x + y$data
as.trackdata(o, inds, ftime, nm)
}

"/.trackdata" <-
function(x, y)
{

if(class(x)=="trackdata")
{
ftime <- x$ftime
inds <- x$index
nm <- x$name
}
else
{
ftime <- y$ftime
inds <- y$index
nm <- y$name
}

# function for doing arithmetic on trackdata objects
# see +.trackdata for examples
if(class(x)=="trackdata" & class(y)=="trackdata")
o <- x$data / y$data
else if (class(x)=="trackdata" & class(y)!="trackdata")
o <- x$data / y
else if (class(x)!="trackdata" & class(y)=="trackdata")
o <- x / y$data
as.trackdata(o, inds, ftime, nm)
}


"*.trackdata" <-
function(x, y)
{

if(class(x)=="trackdata")
{
ftime <- x$ftime
inds <- x$index
nm <- x$name
}
else
{
ftime <- y$ftime
inds <- y$index
nm <- y$name
}

# function for doing arithmetic on trackdata objects
# see +.trackdata for examples
if(class(x)=="trackdata" & class(y)=="trackdata")
o <- x$data * y$data
else if (class(x)=="trackdata" & class(y)!="trackdata")
o <- x$data * y
else if (class(x)!="trackdata" & class(y)=="trackdata")
o <- x * y$data
as.trackdata(o, inds, ftime, nm)
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


## Methods that define operations on the class "trackdata"
## see also track and frames

"print.trackdata"<- function(x, ...)
{
  if(is.null(x$trackname)) 
    cat("trackdata from unknown track.\n")
  else
    cat("trackdata from track:", x$trackname,"\n")

  cat("index:\n")
  print(x$index, ...)
  cat("ftime:\n")
  print(x$ftime, ...)
  cat("data:\n")
  print(x$data, ...)
}

"[.trackdata"<- function(dataset, i, j, ...)
{
  ## dataset[i] gets the data for the i'th segment as a trackdata object

  if (missing(i)) {
    i <- 1:nrow(dataset$index)
  }

  ftime <- dataset$ftime[i, ,drop=F]

  index <- dataset$index[i, ,drop=F]

  ## work out which rows of data we want
  datarows <- NULL
  for( ind in 1:nrow(index) ){
    datarows <- c(datarows, seq(from=index[ind,1], to=index[ind,2]))
  }

  if(is.matrix(dataset$data)){
    if(missing(j))
      data <- dataset$data[datarows, ,drop=F]
    else
      data <- dataset$data[datarows,j,drop=F]
  }
  else {
      data <- dataset$data[datarows, drop=F]
  }

  # now we need to rehash the index matrix to corrspond to the new
  # data matrix

  lval <- index[, 2] - index[, 1] + 1
  right <- cumsum(lval)
  left <- right + 1
  left <- left[ - length(left)]
  left <- c(1, left)
  nindex <- cbind(left, right)

  dataset$index <- nindex
  dataset$ftime <- ftime
  dataset$data <- data
  return(dataset)
}

"summary.trackdata" <- function(object, ...)
{
  if( is.matrix(object$data)){
    dimens <- ncol(object$data)
    len <- nrow(object$data)
  }
  else {
    dimens <- 1
    len <- length(object$data)
  }
  cat("Emu track data from", nrow(object$index), "segments\n\n")
  cat("Data is ", dimens, "dimensional from track", 
      object$trackname,"\n")
  cat("Mean data length is ", len/nrow(object$index), " samples\n")
  invisible()
}


"as.trackdata" <- function( data, index, ftime, trackname="" )
{
  mat <- list( data=as.matrix(data), 
	      index=index, 
	      ftime=ftime,
	      trackname=trackname)
  if( version$major >= 5 ) {
    oldClass(mat) <- "trackdata"
  } else {
    class(mat) <- "trackdata"
  }
  mat
}

"is.trackdata" <-
function (object) 
{
    return(inherits(object, "trackdata"))
}


"plot.trackdata" <-
function (trackdata, timestart=NULL, xlim=NULL, ylim=NULL, labels=NULL, col=NULL, lty=NULL, contig=T, ...)
 {

N <- nrow(trackdata$data)
if(is.null(col))
col <- 1:ncol(trackdata)
if(is.null(lty))
lty <- rep(1, ncol(trackdata))
n <- nrow(trackdata)
# can't plot labels if xlim is specified
if(!is.null(xlim))
labels <- NULL

if(!is.null(labels))
{
if( length(labels) != nrow(trackdata) )
stop("if labels are supplied, there must be one label per segment")
label.times <- apply(trackdata$ftime, 1, mean)
boundary.times <- c(trackdata$ftime[,1], trackdata$ftime[n])
}


if(n > 1 & contig)
{
inds <- cbind(1, N)
ftime <- cbind(trackdata$ftime[1,1], trackdata$ftime[n,2])
trackdata <- as.trackdata(trackdata$data, inds, ftime)
}

if(!is.null(xlim))
{
if(nrow(trackdata)!=1)
stop("can't specify xlim if there's more than one segment")
}

left <- trackdata$ftime[1]
right <- trackdata$ftime[2]
times <- seq(left, right, length=nrow(trackdata$data))
if(!is.null(timestart))
{
times <- times - left + timestart
if(!is.null(labels))
{
label.times <- label.times - left + timestart
boundary.times <- boundary.times - left + timestart
}
}
data <- trackdata$data
if(nrow(trackdata)==1)
{
for(k in 1:ncol(data)){
if(is.null(xlim))
xlim <- range(times)
if(is.null(ylim))
ylim <- range(data)
plot(times, data[,k], xlim=xlim, ylim=ylim, col=col[k], lty=lty[k], ...)
par(new=T)
}
par(new=F)
if(!is.null(labels))
{
if(length(boundary.times) > 2)
abline(v=boundary.times)
mtext(labels, at=label.times)
}
}
else
{
if(is.null(labels))
labels <- rep("", nrow(trackdata))

for(j in 1:nrow(trackdata)){
plot(trackdata[j,], timestart=timestart, xlim=xlim, ylim=ylim, labels=labels[j], contig=T, ...)
}
}
}



# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2002 LTG, Macquarie University               #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

## track.gradinfo  --
## generate various bits of information about a trackdata
## object:
##    - duration
##    - start, end: data values at the start and end of the segment
##    - delta: the difference between start and end data points
##    - slope: the slope of the data (delta/duration)
##
track.gradinfo <- function( trackdata ) {
  result <- dapply(trackdata, track.gradinfo.sub)
  ## all we want is the data which will be one row per segment
  result <- data.frame( result$data )

  ## Put appropriate column headers on the data frame
  ## 
  ## this would be better off in track.gradinfo.sub but
  ## because of the way that dapply works it has to go here
  w <- ncol(trackdata$data)
  names(result) <- c("duration", 
                     paste("start", 1:w, sep=""),
                     paste("end", 1:w, sep=""),
                     paste("delta", 1:w, sep=""),
                     paste("slope", 1:w, sep="") )
  return( result )
}

## track.gradinfo.sub -- 
## do the work of track.gradinfo, return the various
## measures in the right form for dapply
track.gradinfo.sub <- function( data, ftime ) {
  n <- nrow(data)
  dur <- ftime[2]-ftime[1]
  ## delta is the difference between the start and end data points
  delta <- diff( data[c(1,n),] )
  ## slope is the delta/duration
  slope <- delta/dur
  data <- matrix( c( dur, data[1,], data[n,], delta, slope ), nrow=1)

  ## ftime will be discarded anyway but let's do the right thing
  ## and set the start and end to the segment mid point
  mid <- ftime[1]+dur/2
  ftime <- c(mid, mid)
  return( list( data=data, ftime=ftime ) )
}

"trackinfo" <-
function(template)
{
# returns the available track names for a database
# in column 1 and their extensions in column 2
template <- paste(template, "tpl", sep=".")
if(dirname(template)==".")
template <-  paste( dirname(emu.options("bindir")), template, sep="/")
p <- scan(template, what="list", quiet=T)
which <- p=="track"
n <- 1:length(p)
valsa <- n[which]+1
valsb <- n[which]+2
result <- cbind(p[valsa], p[valsb])
dimnames(result) <- list(NULL, c("trackname", "extension"))
result
}

"tracktimes" <-
function(trackdata)
{
if(is.trackdata(trackdata))
# return the times at which the frames
# of trackdata occur as a numerical vector
times <- as.numeric(dimnames(trackdata$data)[[1]])
else if(is.vector(trackdata))
times <- as.numeric(names(trackdata))
else if(is.matrix(trackdata))
times <- as.numeric(dimnames(trackdata)[[1]])
else times <- NULL
times
}







#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################

# compatability and other functions for the R version of Emu/Splus

# are we running R?
# only needed if we aren't since R defines it
if( !exists("is.R") ) {

  is.R <- function() { 
    exists("version") && !is.null(vl <- version$language) && vl == "R"
  }

  ## file.exists is terribly useful
  ## here's a crude version using ls/dir

  if( !exists("file.exists") ) {
    "file.exists" <- function(file) {
      if (emu.platform("Windows")) {
        r <- emu.system(paste("dir", file))
      } else if (emu.platform("Unix")) {
        r <- emu.system(paste("ls", file))
      }
      
      if (length(r) == 0) {
        return(F)
      } else {
        return(T)
      }
    }
  }
}



# system calls are different on each arch. and between S and R

emu.system <- function(cmd) {
  if (is.R()) {
    system(cmd)
  } else if (emu.platform("Windows")) {
    dos(cmd)
  } else if (emu.platform("Unix")) {
    unix(cmd)
  } else {
    stop("don't know how to run a system command -- fix emu.system")
  }
}

## tempfile is fine unless we're on windows where v3.3 can't grok
## long filenames, we need to ensure that when we add .dat and .tim
## on the end we still end up with an 8.3 filename	
## It seems that under R there's no such problem so we'll
## modify this to check for R as well as windows

emu.tempfile <- function(prefix) {
  if( !is.R() && emu.platform("Windows") ){
    tmp <- splitstring(tempfile(""), ".")
    tmp <- paste(tmp[1],tmp[2], sep="x")
    return(tmp)
  } else {
    return(tempfile(prefix))
  }
}

#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"uttplot"<- function(segs, param, data, labtype, colour=T, linetype=F,
                     defcolour = 1, xlim = NULL, ylim = NULL,
                     xlab = "time (ms)",  ylab = "", 
                     main = "", zeros = F, masktrack = "prob_voice",
                     pdat = 0.5, labcol=7,
                     labels = NULL, labeltimes = NULL, labcentre = F,
                     dolabels=T, differ = NULL, smoothing = F, flipped = F, 
                     axes = T, type = "l", ...)
{
  ## written by Jonathan Harrington, 18.9.92
  uttid <- unique(utt(segs))

  nsegs <- nrow(segs)

  values <- emu.track(segs, param)

  if(!missing(data)) values$data <- data
  if(!is.null(differ)) {
    values <- ddiff(values, differ, smoothing=F)
    smoothing <- T
  }
  if(!is.matrix(values$data)) values$data <- cbind(values$data)
  if(smoothing) values$data <- apply(values$data, 2, smooth)
  if(flipped) values$data <- .Uminus(values$data)

  left.time <- values$ftime[1, 1]
  right.time <- values$ftime[nsegs, 2]

  ## colours for label boundaries in white if colour is T
  if(missing(labcol)) {
    if(!colour)
      labcol <- 1
    else
      labcol <- 7
  }

  timevals <- seq(left.time, right.time, length = nrow(values$data))
  if(zeros) {
    pvoice <- emu.track(segs, masktrack)
    temp <- pvoice$data < pdat
    # sometimes prob_voice isn't of the same length of the data, usually only 
    # by one point so we just truncate it if needs be
    if( length(temp) > length(values$data[,1]) )
      temp <- temp[1:(length(values$data[,1]))]
    values$data[!temp,  ] <- NA
  }

  boundtimes <- c(mustart(segs), muend(segs[nrow(segs),  ]))
  if(is.null(xlim)) xlim <- range(c(boundtimes, timevals))
  if(is.null(ylim)) ylim <- range(values$data, na.rm = T)
  
  ## save old par settings to restore later
  oldpar <- par()
#  on.exit(par(oldpar))
  par(...)
  
  col.lty <- mu.colour(1: ncol(values$data), colour, linetype, defcolour)
  if(colour) col.lty$colour <- col.lty$colour+1
  colour <- col.lty$colour
  lty <- col.lty$linetype

  for(j in 1:ncol(values$data)) {
    plot(timevals, values$data[, j], ylim = ylim, xlim = xlim, 
	 xlab = "", ylab = "", main = "", axes = F, col = colour[j], 
	 type = type, lty=lty[j])
        par(new = T)
  }
  if(!missing(labtype)) {
    ## might not work -- need emu.requery
    lefttime <- mustart(segs[1,  ])
    righttime <- muend(segs[nrow(segs),  ])
    segs <- emu.requery( segs, labtype )
    startvals <- mustart(segs)
    endvals <- muend(segs)
    temp <- (startvals < lefttime) | (endvals > righttime)
    segs <- segs[!temp,  ]
  }
  if(!is.null(labeltimes)) {
    ## draw the labels given 
    uttplot.drawlabels( labels, labeltimes, boundtimes, colour=labcol,
                       line=1, dolabels=dolabels  )
  }
  if(!is.null(segs)) {
    ## draw the labelsn from the segment list
    uttplot.drawsegs( segs, colour=labcol, line=1, dolabels=dolabels )
  }
  if(axes){
    axis(1)
    axis(2)
    box()
  }
  title(main = main, ylab = ylab, xlab = xlab)
}


uttplot.drawsegs <- function(segs, colour=1, dolabels=T, line=0) {

  ## work out where to draw the lines
  if( attributes(segs)$type == "event" ) {
    labeltimes <- mustart(segs)
    boundtimes <- labeltimes
  } else {
    labeltimes <- (mustart(segs) + muend(segs))/2
    boundtimes <- c(mustart(segs[1,]), muend(segs))
  }

  uttplot.drawlabels( label(segs), labeltimes, boundtimes, colour,
                     dolabels, line )
}



uttplot.drawlabels <- function( labels, labeltimes, boundtimes,
                               colour=1, dolabels=T, line=0) {
  abline(v = boundtimes, lty = 2, col = colour)
  if(dolabels) {
    for( i in 1:length(labels)  ) {
      mtext(labels[i], side = 3, line = line, at = labeltimes[i], col = colour)
    } 
  } 
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
#############################################################################
#                                                                           #
#   copyright            : (C) 2000 SHLRC, Macquarie University             #
#   email                : Steve.Cassidy@mq.edu.au			    #
#   url			 : http://www.shlrc.mq.edu.au/emu		    #
#									    #
#   This program is free software; you can redistribute it and/or modify    #
#   it under the terms of the GNU General Public License as published by    #
#   the Free Software Foundation; either version 2 of the License, or       #
#   (at your option) any later version.                                     #
#									    #
#############################################################################


"waves.lab"<- function(segs, dir = NULL, extn = ".ilab")
{
# writes out Waves label files from any segment
# list. There will be one label file per utterance
# in segs. The Waves label files are created in the
# directory above the current .Data directory.
# The label files have an extension of .ilab. This
# can be set to any extension name by specifying
# extn= ".lab", for example, to create .lab files
# Note: this extension would overwrite any existing
# .lab files in the directory
# segs: a segment list
# dir: specify a directory where you want the waves files to be written to
# extn: what extension do you want for the Waves label files (
# defaults to .ilab)
  t1 <- "signal unnamed1"
  t2 <- "type 0"
  t3 <- "color 125"
  t4 <- "separator ;"
  t5 <- "nfields 1"
  t6 <- "#"
  header <- rbind(t1, t2, t3, t4, t5, t6)
  utts <- utt(segs)

  for(utt in unique(utts)) {

    temp <- utts == utt
    utt.segs <- segs[temp,  ]
    
    ## sort the segments on their start times
    if(is.matrix(utt.segs))
      utt.segs <- utt.segs[sort.list(as.numeric(mustart(utt.segs))),  ]

    ## work out where to write this utterance
    ## this should involve asking Emu where files
    ## with this extension should live
    if(!is.null(dir)) {
      filename <- paste(dir, "/", utt, extn, sep = "")
    } else {
      filename <- paste(utt, extn, sep = "")
    }
    
    utt.labs <- c("H#", label(utt.segs))
    times <- c(mustart(utt.segs)[1], muend(utt.segs))/1000
    colcode <- rep(125, length(utt.labs))

    mat <- cbind(format(round(times, 6)), colcode, utt.labs)

    cat("Writing to ", filename, "\n" )

    write(t(header), filename)
    write(t(mat), filename, 3, append = T)
  }
}


# Local Variables:
# mode:S
# S-temp-buffer-p:t
# End:
